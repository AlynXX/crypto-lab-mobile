\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}

\geometry{margin=2.5cm}

% Styl listingów
\lstset{
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{blue},
  commentstyle=\color{green!50!black},
  stringstyle=\color{red},
  showstringspaces=false,
  breaklines=true,
  frame=single
}

\title{Dokumentacja Projektu CryptoLab Mobile}
\author{Agnieszka Ryś}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

\newpage
\section{Cel projektu}
Celem aplikacji \textbf{CryptoLab Mobile} jest edukacja w zakresie kryptografii. 
Aplikacja mobilna pozwala szyfrować i deszyfrować teksty oraz pliki \texttt{.txt}, 
sprawdzać poprawność kluczy oraz eksportować wyniki. 
Aplikacja implementuje zarówno klasyczne szyfry historyczne (Cezara, Vigenère'a, szyfr z kluczem bieżącym), 
nowoczesny standard szyfrowania symetrycznego AES (Advanced Encryption Standard),
jak i przełomowy algorytm kryptografii asymetrycznej RSA (Rivest-Shamir-Adleman).
Wszystkie algorytmy są implementowane ręcznie, bez użycia gotowych bibliotek kryptograficznych, 
co pozwala na głębsze zrozumienie ich działania i różnic między kryptografią symetryczną a asymetryczną.

\section{Podstawy kryptografii klasycznej}

\subsection*{Wprowadzenie}
Kryptografia to dziedzina zajmująca się ochroną informacji poprzez jej przekształcanie w formę nieczytelną dla osób nieuprawnionych. 
Jej historia sięga starożytności, gdzie stosowano proste metody szyfrowania, znane obecnie jako \textbf{kryptografia klasyczna}. 
Celem było zapewnienie poufności korespondencji wojskowej, dyplomatycznej czy handlowej. 

\subsection{Kryptografia symetryczna}
W kryptografii symetrycznej ten sam klucz służy zarówno do szyfrowania, jak i deszyfrowania wiadomości. 
Najważniejsze cechy:
\begin{itemize}
    \item wysoka szybkość działania,
    \item konieczność bezpiecznej wymiany klucza,
    \item podatność na ataki brute-force przy krótkich kluczach.
\end{itemize}

\subsection{Przykłady szyfrów klasycznych}
\begin{itemize}
    \item \textbf{Szyfr Cezara} -- przesunięcie liter alfabetu o stałą liczbę pozycji,
    \item \textbf{Szyfr Vigenère'a} -- wieloalfabetyczny szyfr wykorzystujący słowo-klucz,
    \item \textbf{Szyfr z kluczem bieżącym} -- rozwinięcie Vigenère'a z długim kluczem tekstowym,
    \item \textbf{Szyfr podstawieniowy (monoalfabetyczny)} -- każdej literze alfabetu przypisana jest inna litera,
    \item \textbf{Szyfr Playfair} -- operujący na parach liter,
    \item \textbf{Szyfr transpozycyjny} -- zmienia kolejność znaków w wiadomości.
\end{itemize}

\subsection{Znaczenie w edukacji}
Choć współcześnie klasyczne szyfry nie zapewniają realnego bezpieczeństwa, 
stanowią doskonałe narzędzie dydaktyczne. 
Pozwalają zrozumieć podstawowe pojęcia kryptografii, takie jak:
\begin{itemize}
    \item \textbf{klucz} -- parametr definiujący szyfrowanie,
    \item \textbf{przestrzeń kluczy} -- zbiór możliwych wartości klucza,
    \item \textbf{analiza częstości} -- klasyczna metoda łamania szyfrów,
    \item \textbf{brute-force} -- przeszukiwanie wszystkich możliwych kluczy.
\end{itemize}

\subsection{Nowoczesna kryptografia symetryczna -- AES}
Aplikacja CryptoLab zawiera również implementację \textbf{AES (Advanced Encryption Standard)}, 
który jest standardem współczesnego szyfrowania symetrycznego. 
W przeciwieństwie do szyfrów klasycznych, AES:
\begin{itemize}
    \item jest szyfrem \textbf{blokowym} (operuje na blokach 128 bitów),
    \item wykorzystuje złożone operacje matematyczne (S-Box, MixColumns, ShiftRows),
    \item oferuje różne długości kluczy (128, 192, 256 bitów),
    \item obsługuje różne tryby pracy (ECB, CBC, CTR),
    \item jest odporny na wszystkie znane praktyczne ataki kryptograficzne.
\end{itemize}

Dzięki implementacji zarówno szyfrów klasycznych, jak i nowoczesnego AES, 
użytkownicy mogą porównać podejścia historyczne z obecnie stosowanymi rozwiązaniami 
i zrozumieć ewolucję kryptografii.

\section{Miejsce szyfru Cezara}
Szyfr Cezara należy do najprostszych szyfrów podstawieniowych. 
Choć jego bezpieczeństwo jest znikome, odgrywa on kluczową rolę w nauczaniu, 
ponieważ wprowadza intuicyjnie pojęcia klucza, szyfrowania i deszyfrowania. 
CryptoLab wykorzystuje go jako \textbf{pierwszy krok} w implementacji i analizie algorytmów kryptograficznych.


\section{Technologie wykorzystane w projekcie}

\begin{description}
    \item[\textbf{React Native + Expo}] 
    Główna platforma wykorzystana do tworzenia aplikacji mobilnych. 
    React Native umożliwia budowanie natywnych aplikacji na systemy Android i iOS, wykorzystując składnię zbliżoną do Reacta. 
    Expo zostało użyte jako narzędzie wspierające proces developmentu – upraszcza konfigurację środowiska, przyspiesza testowanie na urządzeniach mobilnych i zapewnia dostęp do bogatego ekosystemu bibliotek.

    \item[\textbf{TypeScript}] 
    Nadzbiór JavaScriptu wprowadzający system typów. 
    Zastosowanie TypeScriptu pozwoliło na: 
    \begin{itemize}
        \item wcześniejsze wykrywanie błędów podczas kompilacji,
        \item lepszą kontrolę nad strukturą danych i interfejsami,
        \item zwiększoną czytelność oraz przewidywalność kodu,
    \end{itemize}

    \item[\textbf{Expo Document Picker, File System, Vector Icons}] 
    Dodatkowe biblioteki środowiska Expo: 
    \begin{itemize}
        \item \texttt{expo-document-picker} – umożliwia wybór plików z pamięci urządzenia, 
        \item \texttt{expo-file-system} – zapewnia dostęp do systemu plików (zapisywanie, odczyt, usuwanie plików),
        \item \texttt{expo-vector-icons} – biblioteka ikon pozwalająca wzbogacić interfejs użytkownika.
    \end{itemize}

    \item[\textbf{Git}] 
    System kontroli wersji użyty do zarządzania historią kodu. 
    Pozwolił na prowadzenie szczegółowego changelogu, śledzenie postępów w projekcie oraz łatwe zarządzanie zmianami w kodzie źródłowym.

    \item[\textbf{LaTeX}] 
    System składu tekstu wykorzystany do przygotowania dokumentacji. 
    Umożliwia on: 
    \begin{itemize}
        \item zachowanie spójności formatowania,
        \item wygodne dodawanie fragmentów kodu źródłowego i zrzutów ekranu,
        \item automatyczne generowanie spisów treści i numeracji.
    \end{itemize}
\end{description}

\newpage

\section{Architektura systemu}

\subsection{Wzorzec projektowy}
Aplikacja wykorzystuje \textbf{Strategy Pattern} dla algorytmów kryptograficznych. 
Każdy algorytm dziedziczy z klasy abstrakcyjnej \texttt{CryptographicAlgorithm} i implementuje metody:
\begin{itemize}
    \item \texttt{encrypt(plaintext, key)} -- szyfruje tekst,
    \item \texttt{decrypt(ciphertext, key)} -- deszyfruje tekst,
    \item \texttt{validateKey(key)} -- sprawdza poprawność klucza,
    \item \texttt{getKeyRequirements()} -- zwraca opis wymagań dla klucza.
\end{itemize}

Wszystkie algorytmy zarejestrowane są w \texttt{AlgorithmRegistry} (Singleton Pattern), 
co umożliwia łatwe dodawanie nowych szyfrów bez modyfikacji głównej aplikacji.

\subsection{Komponenty główne}
\begin{itemize}
    \item \textbf{App.tsx} -- główny komponent aplikacji, obsługuje interfejs użytkownika,
    \item \textbf{AlgorithmSidebar.tsx} -- boczny panel z listą dostępnych algorytmów,
    \item \textbf{LogsViewer.tsx} -- komponent wyświetlania historii operacji kryptograficznych,
    \item \textbf{AlgorithmRegistry.ts} -- rejestr i zarządzanie algorytmami,
    \item \textbf{CryptographicAlgorithm.ts} -- klasa bazowa dla wszystkich algorytmów,
    \item \textbf{LogManager.ts} -- menadżer logów z wzorcem Singleton,
    \item \textbf{fileUtils.ts} -- funkcje do obsługi operacji na plikach.
\end{itemize}

\section{Struktura projektu}
\begin{lstlisting}
crypto-lab-mobile/
├── App.tsx                          (glowny komponent)
├── package.json                     (zalezności projektu)
├── tsconfig.json                    (konfiguracja TypeScriptu)
├── app.json                         (konfiguracja Expo)
├── src/
│   ├── algorithms/
│   │   ├── CryptographicAlgorithm.ts   (klasa bazowa)
│   │   ├── CaesarCipher.ts             (szyfr Cezara)
│   │   ├── VigenereCipher.ts           (szyfr Vigenere'a)
│   │   ├── RunningKeyCipher.ts         (szyfr z kluczem biezacym)
│   │   ├── AESCipher.ts                (szyfr AES)
│   │   ├── RSACipher.ts                (szyfr RSA)
│   │   └── AlgorithmRegistry.ts        (rejestr algorytmow)
│   ├── components/
│   │   ├── AlgorithmSidebar.tsx        (panel z algorytmami)
│   │   └── LogsViewer.tsx              (wyswietlanie logow)
│   ├── types/
│   │   └── LogTypes.ts                 (typy dla systemu logow)
│   └── utils/
│       ├── fileUtils.ts                (obsluga plikow)
│       └── LogManager.ts               (zarzadzanie logami)
└── assets/                          (zasoby graficzne)
\end{lstlisting}
\section{Implementacja szyfru Cezara}
\subsection{Podstawy}
Szyfr Cezara to prosty szyfr monoalfabetyczny, w którym litery przesuwane są o wartość klucza $k$. 
Przestrzeń kluczy obejmuje wartości $1$--$25$. 
Metoda jest podatna na ataki brute-force i analizę częstotliwości.

\subsection{Model matematyczny}
\begin{itemize}
    \item Szyfrowanie: $E_k(x) = (x + k) \bmod 26$,
    \item Deszyfrowanie: $D_k(x) = (x - k) \bmod 26$.
\end{itemize}

\subsection{Cechy implementacji}
\begin{itemize}
    \item Obsługuje zarówno wielkie jak i małe litery,
    \item Znaki niebędące literami pozostają bez zmian,
    \item Klucz musi być liczbą całkowitą z zakresu 1--25,
    \item Walidacja klucza zwraca szczegółową informację o błędach.
\end{itemize}

\newpage
\section{Implementacja szyfru Vigenère'a}

\subsection{Historia i znaczenie}
Szyfr Vigenère'a został opracowany w XVI wieku przez Blaise de Vigenère'a. 
Przez długi czas uważany był za niezniszczalny (\textit{le chiffre indéchiffrable}) 
aż do jego przełamania przez Charles'a Babbage'a w XIX wieku.

\subsection{Podstawy}
Szyfr Vigenère'a to szyfr \textbf{polialfabetyczny}, który wykorzystuje słowo-klucz 
do generowania serii przesunięć. W przeciwieństwie do szyfru Cezara, 
każda litera tekstu może być szyfrowana z innym przesunięciem.

\subsection{Model matematyczny}
\begin{itemize}
    \item Szyfrowanie: $E_{k}(x_i) = (x_i + k_{i \bmod |k|}) \bmod 26$,
    \item Deszyfrowanie: $D_{k}(y_i) = (y_i - k_{i \bmod |k|}) \bmod 26$,
    \item gdzie $k$ to słowo-klucz, a $|k|$ to jego długość.
\end{itemize}

\subsection{Przykład działania}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Tekst jawny & A & T & T & A & C & K \\
\hline
Klucz & L & E & M & O & N & L \\
\hline
Przesunięcia & +11 & +4 & +12 & +14 & +13 & +11 \\
\hline
Tekst zaszyfrowany & L & X & F & O & P & V \\
\hline
\end{tabular}
\end{center}

\subsection{Cechy implementacji}
\begin{itemize}
    \item Klucz może zawierać tylko litery (A-Z, a-z),
    \item Klucz nie może być pusty,
    \item Znaki niebędące literami w tekście źródłowym są przepisywane bez zmian,
    \item Klucz automatycznie się powtarza dla długich tekstów,
    \item Obsługuje zarówno wielkie jak i małe litery w tekście.
\end{itemize}
\newpage
\section{Implementacja szyfru z kluczem bieżącym}

\subsection{Historia i zastosowanie}
Szyfr z kluczem bieżącym (Running Key Cipher) to rozwinięcie szyfru Vigenère'a. 
Zamiast krótko słowa, wykorzystuje on klucz o długości co najmniej równej długości tekstu. 
Gdy klucz jest naprawdę losowy i będzie użyty tylko raz, szyfr ten jest teoretycznie nie do złamania 
(jest to wariant szyfru jednorazowego -- \textit{One-Time Pad}).

\subsection{Podstawy}
Algorytm jest w zasadzie identyczny z szyfrem Vigenère'a, ale z istotną różnicą: 
klucz powinien być znacznie dłuższy niż tekst. W praktyce zastosowania edukacyjnego 
aplikacja automatycznie generuje klucz z tekstu Lorem Ipsum.

\subsection{Model matematyczny}
\begin{itemize}
    \item Szyfrowanie: $E_{k}(x_i) = (x_i + k_i) \bmod 26$,
    \item Deszyfrowanie: $D_{k}(y_i) = (y_i - k_i) \bmod 26$,
    \item gdzie $|k| \geq |x|$ (klucz jest co najmniej tak długi jak tekst).
\end{itemize}

\subsection{Cechy implementacji}
\begin{itemize}
    \item Klucz może zawierać litery i spacje,
    \item Klucz musi zawierać co najmniej 5 liter,
    \item Aplikacja automatycznie generuje losowy klucz na bazie Lorem Ipsum,
    \item Zaszyfrowany tekst zawiera klucz w formacie: \texttt{<klucz>::<tekst\_zaszyfrowany>},
    \item Deszyfrowanie wymaga podania tekstu w poprawnym formacie.
\end{itemize}

\subsection{Bezpieczeństwo}
\begin{itemize}
    \item Gdy klucz jest losowy i używany tylko raz, szyfr jest teoretycznie bezpieczny,
    \item Słaba strona: jeśli klucz jest krótszy niż tekst, powtarza się i traci bezpieczeństwo,
    \item W aplikacji edukacyjne klucz jest generowany automatycznie i przechowywany w wynikach.
\end{itemize}

\newpage
\section{Implementacja szyfru AES}

\subsection{Historia i znaczenie}
AES (Advanced Encryption Standard) to symetryczny szyfr blokowy, który w 2001 roku został wybrany przez NIST (National Institute of Standards and Technology) jako następca przestarzałego algorytmu DES. 
Został opracowany przez belgijskich kryptografów Joana Daemena i Vincenta Rijmena pod nazwą \textit{Rijndael}. 
AES jest obecnie najpowszechniej stosowanym szyfrem symetrycznym na świecie -- chroni dane w protokołach SSL/TLS, systemach bankowych, szyfrowanych dyskach i wielu innych zastosowaniach.

\subsection{Podstawy}
AES to szyfr \textbf{blokowy}, który operuje na blokach danych o długości 128 bitów (16 bajtów). 
W przeciwieństwie do szyfrów klasycznych, AES wykorzystuje skomplikowane operacje matematyczne na macierzach bajtów, 
w tym podstawienia (S-Box), permutacje, mieszanie kolumn i dodawanie klucza rundowego.

\subsection{Warianty AES}
AES występuje w trzech wariantach, różniących się długością klucza:
\begin{itemize}
    \item \textbf{AES-128} -- klucz 128-bitowy (32 znaki hex), 10 rund szyfrowania,
    \item \textbf{AES-192} -- klucz 192-bitowy (48 znaków hex), 12 rund szyfrowania,
    \item \textbf{AES-256} -- klucz 256-bitowy (64 znaki hex), 14 rund szyfrowania.
\end{itemize}

Im dłuższy klucz, tym wyższe bezpieczeństwo, ale także nieznacznie wolniejsze działanie.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/strona_glownaAES.jpg}
    \caption{Strona główna szyfru AES w aplikacji CryptoLab}
    \label{fig:aes_main}
\end{figure}
Rysunek \ref{fig:aes_main} przedstawia interfejs użytkownika aplikacji CryptoLab Mobile dla szyfru AES.
\subsection{Tryby pracy AES}
Szyfr blokowy wymaga określenia \textbf{trybu pracy}, który definiuje sposób szyfrowania wielu bloków danych:

\begin{description}
    \item[\textbf{ECB (Electronic Codebook)}] 
    Najprostszy tryb -- każdy blok szyfrowany jest niezależnie tym samym kluczem. 
    \textbf{Niezalecany} w praktyce, ponieważ identyczne bloki tekstu jawnego dają identyczne bloki szyfrogramu, 
    co może ujawnić wzorce w danych.
    \begin{figure}
        \centering
        \includegraphics[width=0.3\textwidth]{img/ECB.jpg}
        \caption{Tryb ECB w szyfrze AES}
        \label{fig:ecb}
    \end{figure}
    Rysunek \ref{fig:ecb} przedstawia przykładowe szyfrowanie tekstu w trybiie ECB.
    
    \item[\textbf{CBC (Cipher Block Chaining)}] 
    Każdy blok tekstu jawnego jest najpierw XOR-owany z poprzednim blokiem szyfrogramu przed zaszyfrowaniem. 
    Wymaga wektora inicjalizującego (IV). Tryb ten ukrywa wzorce w danych i jest szeroko stosowany.
    \begin{figure}
        \centering
        \includegraphics[width=0.3\textwidth]{img/CBC.jpg}
        \caption{Tryb CBC w szyfrze AES}
        \label{fig:cbc}
    \end{figure}
    Rysunek \ref{fig:cbc} przedstawia przykładowe deszyfrowanie tekstu w trybiie CBC.
    \item[\textbf{CTR (Counter Mode)}] 
    Przekształca szyfr blokowy w szyfr strumieniowy. 
    Szyfruje kolejne wartości licznika, a wyniki XOR-uje z blokami tekstu jawnego. 
    Umożliwia równoległe szyfrowanie i deszyfrowanie.
    \begin{figure}
        \centering
        \includegraphics[width=0.3\textwidth]{img/CTR.jpg}
        \caption{Tryb CTR w szyfrze AES}
        \label{fig:ctr}
    \end{figure}
    Rysunek \ref{fig:ctr} przedstawia przykładowe szyfrowanie tekstu w trybiie CTR.
\end{description}

\subsection{Struktura algorytmu AES}
Algorytm AES składa się z następujących kroków (dla każdej rundy):
\begin{enumerate}
    \item \textbf{SubBytes} -- podstawienie bajtów zgodnie z tablicą S-Box,
    \item \textbf{ShiftRows} -- przesunięcie wierszy macierzy stanu,
    \item \textbf{MixColumns} -- mieszanie kolumn macierzy (pomijane w ostatniej rundzie),
    \item \textbf{AddRoundKey} -- dodanie klucza rundowego (operacja XOR).
\end{enumerate}

Przed pierwszą rundą wykonywana jest operacja \texttt{AddRoundKey} z kluczem początkowym.

\subsection{Cechy implementacji}
\begin{itemize}
    \item Obsługuje klucze w formacie szesnastkowym (hex),
    \item Klucz musi mieć długość 32, 48 lub 64 znaki hex (AES-128/192/256),
    \item Domyślny klucz: \texttt{2b7e151628aed2a6abf7158809cf4f3c} (AES-128),
    \item Implementuje trzy tryby pracy: ECB, CBC, CTR,
    \item Używa paddingu PKCS\#7 dla dopełnienia bloków,
    \item Generuje losowy wektor inicjalizujący (IV) dla trybów CBC i CTR,
    \item Wynik szyfrowania zwracany w formacie hex,
    \item Pełna implementacja bez użycia zewnętrznych bibliotek kryptograficznych.
\end{itemize}

\subsection{Bezpieczeństwo}
\begin{itemize}
    \item AES jest uważany za \textbf{kryptograficznie bezpieczny} przy prawidłowym użyciu,
    \item Nie znaleziono praktycznych ataków na pełny AES-128, AES-192 ani AES-256,
    \item Teoretyczne ataki istnieją, ale wymagają zasobów przekraczających możliwości obecnej technologii,
    \item Bezpieczeństwo zależy od:
    \begin{itemize}
        \item wyboru odpowiedniego trybu pracy (CBC lub CTR zamiast ECB),
        \item użycia losowego IV dla trybów CBC i CTR,
        \item odpowiedniej długości klucza (zalecane minimum: AES-128),
        \item bezpiecznego przechowywania i dystrybucji klucza.
    \end{itemize}
\end{itemize}

\subsection{Zastosowania}
AES jest wykorzystywany w:
\begin{itemize}
    \item szyfrowanie połączeń internetowych (HTTPS, SSL/TLS),
    \item pełne szyfrowanie dysków (BitLocker, FileVault),
    \item sieci bezprzewodowe (WPA2, WPA3),
    \item aplikacje bankowe i systemy płatności,
    \item komunikatory szyfrowane (Signal, WhatsApp),
    \item archiwizacja danych (7-Zip, WinRAR z szyfrowaniem AES).
\end{itemize}

\newpage
\section{Kryptografia asymetryczna -- RSA}

\subsection{Historia i znaczenie}
RSA (Rivest-Shamir-Adleman) to pierwszy praktyczny algorytm kryptografii asymetrycznej, 
opublikowany w 1977 roku przez Rona Rivesta, Adi Shamira i Leonarda Adlemana z MIT.
RSA rozwiązał fundamentalny problem kryptografii symetrycznej: 
\textbf{bezpieczną wymianę kluczy}.

W kryptografii asymetrycznej każdy użytkownik posiada parę kluczy:
\begin{itemize}
    \item \textbf{klucz publiczny} -- może być swobodnie udostępniany, służy do szyfrowania,
    \item \textbf{klucz prywatny} -- musi być tajny, służy do deszyfrowania.
\end{itemize}

To rewolucyjne podejście umożliwiło bezpieczną komunikację bez wcześniejszej wymiany tajnego klucza.

\subsection{Podstawy matematyczne}
Bezpieczeństwo RSA opiera się na trudności \textbf{faktoryzacji dużych liczb złożonych}. 
Łatwo jest pomnożyć dwie duże liczby pierwsze, ale bardzo trudno rozłożyć ich iloczyn na czynniki pierwsze.

\subsection{Model matematyczny}

\textbf{Generowanie kluczy:}
\begin{enumerate}
    \item Wybierz dwie duże liczby pierwsze: $p$ i $q$
    \item Oblicz moduł: $n = p \cdot q$
    \item Oblicz funkcję Eulera: $\phi(n) = (p-1)(q-1)$
    \item Wybierz wykładnik publiczny $e$, taki że: $1 < e < \phi(n)$ oraz $\gcd(e, \phi(n)) = 1$
    \item Oblicz wykładnik prywatny $d$, taki że: $d \cdot e \equiv 1 \pmod{\phi(n)}$
    \item Klucz publiczny: $(e, n)$
    \item Klucz prywatny: $(d, n)$
\end{enumerate}

\textbf{Szyfrowanie i deszyfrowanie:}
\begin{itemize}
    \item Szyfrowanie (klucz publiczny): $c = m^e \bmod n$
    \item Deszyfrowanie (klucz prywatny): $m = c^d \bmod n$
    \item gdzie $m$ -- wiadomość, $c$ -- szyfrogram
\end{itemize}

\subsection{Przykład działania}
Niech $p = 61$, $q = 53$:
\begin{align*}
n &= 61 \cdot 53 = 3233 \\
\phi(n) &= 60 \cdot 52 = 3120 \\
e &= 17 \quad (\gcd(17, 3120) = 1) \\
d &= 2753 \quad (17 \cdot 2753 \equiv 1 \pmod{3120})
\end{align*}

\textbf{Klucz publiczny:} $(17, 3233)$ \\
\textbf{Klucz prywatny:} $(2753, 3233)$

Szyfrowanie litery 'A' (kod ASCII: 65):
$$c = 65^{17} \bmod 3233 = 2790$$

Deszyfrowanie:
$$m = 2790^{2753} \bmod 3233 = 65$$

\subsection{Cechy implementacji}
\begin{itemize}
    \item Generowanie par kluczy z losowymi liczbami pierwszymi,
    \item Dla celów edukacyjnych używa małych liczb pierwszych (100-300),
    \item W praktyce RSA wymaga liczb o długości 2048+ bitów,
    \item Implementuje algorytm Euklidesa dla obliczenia NWD,
    \item Rozszerzony algorytm Euklidesa dla odwrotności modularnej,
    \item Szybkie potęgowanie modularne dla efektywnego szyfrowania,
    \item Format kluczy: "wykładnik,moduł" (np. "17,3233"),
    \item Każdy znak tekstu szyfrowany osobno,
    \item Wynik w postaci liczb rozdzielonych spacjami.
\end{itemize}

\subsection{Jak wygenerować klucze RSA}
Aplikacja mobilna posiada wbudowaną funkcję generowania kluczy RSA bezpośrednio w interfejsie użytkownika.

\textbf{Generowanie kluczy w aplikacji (zalecane):}
\begin{enumerate}
    \item Wybierz algorytm RSA z listy
    \item Kliknij przycisk \textbf{"Generuj klucze"} obok pola klucza
    \item Aplikacja wyświetli okno z wygenerowanymi kluczami:
    \begin{itemize}
        \item Klucz publiczny (do szyfrowania)
        \item Klucz prywatny (do deszyfrowania)
    \end{itemize}
    \item Możesz skopiować klucze lub bezpośrednio użyć jednego z nich
    \item Zapisz oba klucze w bezpiecznym miejscu!
\end{enumerate}

\textbf{Opcja 1: Użycie przykładowych kluczy testowych}
\begin{itemize}
    \item Klucz publiczny: \texttt{17,323} (e=17, n=323)
    \item Klucz prywatny: \texttt{233,323} (d=233, n=323)
\end{itemize}

\textbf{Opcja 2: Wygenerowanie własnych kluczy w konsoli przeglądarki}
\begin{lstlisting}[language=JavaScript, caption={Generowanie kluczy RSA w konsoli}]
// Skopiuj kod RSACipher do konsoli, a nastepnie:
const rsa = new RSACipher();
const keys = rsa.generateKeyPair();
console.log('Klucz publiczny:', rsa.formatPublicKey());
console.log('Klucz prywatny:', rsa.formatPrivateKey());
\end{lstlisting}

\textbf{Opcja 3: Obliczenie ręczne (cel edukacyjny)}
\begin{enumerate}
    \item Wybierz dwie małe liczby pierwsze, np. p=17, q=19
    \item Oblicz n = p × q = 323
    \item Oblicz φ(n) = (p-1)(q-1) = 16 × 18 = 288
    \item Wybierz e takie, że NWD(e, 288) = 1, np. e=17
    \item Oblicz d = e$^{-1}$ mod φ(n), np. d=233
    \item Klucz publiczny: (17, 323), klucz prywatny: (233, 323)
\end{enumerate}

\subsection{Bezpieczeństwo}
\begin{itemize}
    \item RSA jest bezpieczny przy użyciu odpowiednio dużych kluczy (2048+ bitów),
    \item Bezpieczeństwo opiera się na trudności faktoryzacji dużych liczb,
    \item Zagrożenia:
    \begin{itemize}
        \item Komputery kwantowe (algorytm Shora może złamać RSA),
        \item Zbyt małe klucze (łatwa faktoryzacja),
        \item Słabe generatory liczb pierwszych,
        \item Ataki czasowe (timing attacks) przy nieodpowiedniej implementacji.
    \end{itemize}
    \item Zalecenia:
    \begin{itemize}
        \item Minimum 2048 bitów dla zastosowań praktycznych,
        \item 3072-4096 bitów dla długoterminowego bezpieczeństwa,
        \item Używanie sprawdzonych bibliotek kryptograficznych w produkcji.
    \end{itemize}
\end{itemize}

\subsection{Zastosowania}
RSA jest wykorzystywany w:
\begin{itemize}
    \item \textbf{Podpisy cyfrowe} -- uwierzytelnianie dokumentów i oprogramowania,
    \item \textbf{Wymiana kluczy} -- bezpieczne przesyłanie kluczy symetrycznych (SSL/TLS),
    \item \textbf{Certyfikaty SSL/TLS} -- zabezpieczenie połączeń HTTPS,
    \item \textbf{SSH} -- bezpieczne logowanie do serwerów,
    \item \textbf{PGP/GPG} -- szyfrowanie poczty elektronicznej,
    \item \textbf{Blockchain} -- weryfikacja transakcji w kryptowalutach.
\end{itemize}

\subsection{RSA vs AES}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Cecha} & \textbf{RSA} & \textbf{AES} \\
\hline
Typ & Asymetryczny & Symetryczny \\
\hline
Klucze & Para: publiczny + prywatny & Jeden klucz dla obu stron \\
\hline
Szybkość & Wolniejszy (100-1000x) & Bardzo szybki \\
\hline
Rozmiar klucza & 2048-4096 bitów & 128-256 bitów \\
\hline
Wymiana klucza & Nie wymaga & Wymaga bezpiecznego kanału \\
\hline
Zastosowanie & Wymiana kluczy, podpisy & Szyfrowanie danych \\
\hline
\end{tabular}
\end{center}

W praktyce RSA i AES są używane razem: RSA do bezpiecznej wymiany klucza AES, 
a następnie AES do szyfrowania właściwych danych (\textit{hybrid cryptography}).

\newpage
\section{Algorytm ElGamal}

\subsection{Historia i znaczenie}
System szyfrowania ElGamal został zaproponowany przez Tahera ElGamala w 1985 roku. 
Jest to asymetryczny algorytm klucza publicznego, którego bezpieczeństwo opiera się na trudności problemu \textbf{logarytmu dyskretnego} w ciałach skończonych. 
Algorytm ten jest rozwinięciem protokołu wymiany kluczy Diffiego-Hellmana.

\subsection{Model matematyczny}
Bezpieczeństwo systemu opiera się na fakcie, że choć łatwo jest obliczyć potęgę $g^x \pmod p$, to bardzo trudno jest obliczyć wykładnik $x$, znając jedynie wynik potęgowania, podstawę i moduł (gdy liczby są odpowiednio duże).

\textbf{Generowanie kluczy:}
\begin{enumerate}
    \item Wybierz dużą liczbę pierwszą $p$.
    \item Znajdź generator $g$ (pierwiastek pierwotny modulo $p$).
    \item Wybierz losowy klucz prywatny $x$, taki że $1 < x < p-1$.
    \item Oblicz klucz publiczny $y = g^x \pmod p$.
    \item Klucz publiczny: $(p, g, y)$, Klucz prywatny: $(x, p)$.
\end{enumerate}

\textbf{Szyfrowanie:}
Aby zaszyfrować wiadomość $m$ dla odbiorcy z kluczem publicznym $(p, g, y)$:
\begin{enumerate}
    \item Wybierz losową liczbę $k$ (klucz efemeryczny), taką że $1 < k < p-1$.
    \item Oblicz $a = g^k \pmod p$.
    \item Oblicz $b = (y^k \cdot m) \pmod p$.
    \item Szyfrogram to para $(a, b)$.
\end{enumerate}

\textbf{Deszyfrowanie:}
Aby odszyfrować parę $(a, b)$ przy użyciu klucza prywatnego $x$:
\begin{enumerate}
    \item Oblicz współczynnik $s = a^x \pmod p$.
    \item Oblicz odwrotność $s^{-1} \pmod p$.
    \item Wiadomość $m = b \cdot s^{-1} \pmod p$.
\end{enumerate}

\subsection{Cechy implementacji}
\begin{itemize}
    \item Implementacja wykorzystuje liczby pierwsze w zakresie 300-1000 dla celów edukacyjnych (umożliwia kodowanie znaków ASCII).
    \item Każdy znak wiadomości jest szyfrowany osobno, co generuje parę liczb $(a, b)$.
    \item Wykorzystuje losowy klucz $k$ dla każdego szyfrowania, co oznacza, że ten sam tekst zaszyfrowany dwukrotnie da inny wynik (niedeterministyczność).
    \item Implementuje algorytm znajdowania pierwiastka pierwotnego.
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=0.3\textwidth]{img/elgamal_szyfr.jpg}
    \caption{Ekran szyfru ElGamal w aplikacji CryptoLab}
    \label{fig:elgamal}
\end{figure}
Rysunek \ref{fig:elgamal} przedstawia interfejs użytkownika aplikacji CryptoLab Mobile dla szyfru ElGamal.

\begin{figure}
    \centering
    \includegraphics[width=0.3\textwidth]{img/elgamal_deszyfr.jpg}
    \caption{Ekran deszyfru ElGamal w aplikacji CryptoLab}
    \label{fig:elgamal_decrypt}
\end{figure}
Rysunek \ref{fig:elgamal_decrypt} przedstawia interfejs użytkownika aplikacji CryptoLab Mobile dla deszyfru ElGamal.
\section{Protokół ECDH i Krzywe Eliptyczne}

\subsection{Wprowadzenie do ECC}
Kryptografia krzywych eliptycznych (ECC - Elliptic Curve Cryptography) opiera się na strukturze algebraicznej krzywych eliptycznych nad ciałami skończonych. 
Główną zaletą ECC jest to, że zapewnia ten sam poziom bezpieczeństwa co RSA, ale przy znacznie krótszych kluczach (np. 256-bitowy klucz ECC jest porównywalny z 3072-bitowym kluczem RSA).

Równanie krzywej Weierstrassa:
$$y^2 = x^3 + ax + b \pmod p$$

\subsection{Protokół ECDH (Elliptic Curve Diffie-Hellman)}
ECDH to wariant protokołu Diffiego-Hellmana wykorzystujący krzywe eliptyczne. Służy do uzgodnienia wspólnego sekretu przez dwie strony, które nigdy się nie spotkały, korzystając z niezabezpieczonego kanału.

\textbf{Zasada działania:}
\begin{enumerate}
    \item Strony uzgadniają parametry krzywej (punkt bazowy $G$, parametry $a, b, p$).
    \item Alice generuje prywatny klucz $d_A$ i oblicza publiczny $Q_A = d_A \cdot G$.
    \item Bob generuje prywatny klucz $d_B$ i oblicza publiczny $Q_B = d_B \cdot G$.
    \item Strony wymieniają się kluczami publicznymi.
    \item Alice oblicza sekret $S = d_A \cdot Q_B$.
    \item Bob oblicza sekret $S = d_B \cdot Q_A$.
    \item Ponieważ $d_A \cdot (d_B \cdot G) = d_B \cdot (d_A \cdot G)$, obie strony uzyskują ten sam punkt $S$.
\end{enumerate}

\subsection{Implementacja w CryptoLab (ECIES)}
W aplikacji zaimplementowano schemat szyfrowania ECIES (Elliptic Curve Integrated Encryption Scheme) wykorzystujący ECDH:
\begin{itemize}
    \item Nadawca generuje tymczasową parę kluczy (klucz efemeryczny).
    \item Oblicza wspólny sekret z kluczem publicznym odbiorcy.
    \item Współrzędna X punktu sekretnego służy jako klucz symetryczny (w uproszczeniu XOR).
    \item Do szyfrogramu dołączany jest klucz publiczny efemeryczny, aby odbiorca mógł odtworzyć sekret.
\end{itemize}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/klucze_ecdh.jpg}
    \caption{Wygenerowane klucze ECDH w aplikacji CryptoLab}
    \label{fig:ecdh}
\end{figure}
Rysunek \ref{fig:ecdh} przedstawia wygenerowane klucze ECDH w aplikacji CryptoLab Mobile.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/ecdh_szyfrowanie.jpg}
    \caption{Proces szyfrowania ECDH w aplikacji CryptoLab}
    \label{fig:ecdh_encrypt}
\end{figure}
Rysunek \ref{fig:ecdh_encrypt} przedstawia proces szyfrowania ECDH w aplikacji CryptoLab Mobile.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/ecdh_deszyfr.jpg}
    \caption{Proces deszyfrowania ECDH w aplikacji CryptoLab}
    \label{fig:ecdh_decrypt}
\end{figure}
Rysunek \ref{fig:ecdh_decrypt} przedstawia proces deszyfrowania ECDH w aplikacji CryptoLab Mobile.
\subsection{Cechy implementacji}
\begin{itemize}
    \item Używa zdefiniowanej na sztywno małej krzywej eliptycznej dla celów edukacyjnych.
    \item Implementuje dodawanie punktów i mnożenie skalarne na krzywej.
    \item Wizualizuje proces generowania wspólnego sekretu w logach.
\end{itemize}

\section{Funkcja skrótu SHA-256}

\subsection{Wprowadzenie do funkcji skrótu}
Funkcje skrótu (ang. \textit{hash functions}) to kluczowy element współczesnej kryptografii.
W odróżnieniu od szyfrów, które są dwukierunkowymi przekształceniami, funkcje skrótu są \textbf{jednokierunkowe} -- 
nie można ich odwrócić. Dla dowolnego wejścia generują skrót stałej długości.

\textbf{Główne cechy funkcji skrótu:}
\begin{itemize}
    \item \textbf{Jednokierunkowość} -- obliczeniowo niemożliwe jest odtworzenie wiadomości ze skrótu,
    \item \textbf{Deterministyczność} -- ta sama wiadomość zawsze daje ten sam skrót,
    \item \textbf{Efekt lawiny} -- najmniejsza zmiana w wejściu powoduje drastyczną zmianę skrótu,
    \item \textbf{Odporność na kolizje} -- trudno znaleźć dwie różne wiadomości dające ten sam skrót,
    \item \textbf{Stała długość wyjścia} -- niezależnie od rozmiaru wejścia, skrót ma zawsze tę samą długość.
\end{itemize}

\subsection{SHA-256 (Secure Hash Algorithm 256-bit)}
SHA-256 należy do rodziny algorytmów SHA-2, opracowanych przez NSA i opublikowanych przez NIST w 2001 roku.
Jest to aktualnie jeden z najpopularniejszych i najbezpieczniejszych algorytmów haszujących.

\textbf{Parametry SHA-256:}
\begin{itemize}
    \item Długość skrótu: 256 bitów (64 znaki szesnastkowe),
    \item Rozmiar bloku: 512 bitów,
    \item Liczba rund: 64,
    \item Używa operacji bitowych (XOR, AND, OR, NOT, rotacje, przesunięcia).
\end{itemize}

\subsection{Algorytm SHA-256}
Proces haszowania SHA-256 składa się z następujących etapów:

\textbf{1. Preprocessing (przygotowanie wiadomości):}
\begin{itemize}
    \item Dodanie bitu '1' na końcu wiadomości,
    \item Dodanie zer dopełniających do osiągnięcia długości $\equiv 448 \pmod{512}$ bitów,
    \item Dodanie 64-bitowej reprezentacji długości oryginalnej wiadomości.
\end{itemize}

\textbf{2. Inicjalizacja wartości początkowych (H):}

Ośmiu 32-bitowych stałych (pierwsze 32 bity ułamkowych części pierwiastków kwadratowych pierwszych 8 liczb pierwszych):
$$H_0 = \text{0x6a09e667}, H_1 = \text{0xbb67ae85}, \ldots, H_7 = \text{0x5be0cd19}$$

\textbf{3. Przetwarzanie bloków 512-bitowych:}

Dla każdego bloku:
\begin{enumerate}
    \item Przygotowanie harmonogramu wiadomości $W_0, W_1, \ldots, W_{63}$ (pierwsze 16 słów to dane wejściowe, pozostałe obliczane z funkcji $\sigma$),
    \item 64 rundy kompresji z użyciem funkcji logicznych:
    \begin{itemize}
        \item $Ch(x,y,z) = (x \land y) \oplus (\neg x \land z)$ -- funkcja wyboru,
        \item $Maj(x,y,z) = (x \land y) \oplus (x \land z) \oplus (y \land z)$ -- funkcja większości,
        \item $\Sigma_0, \Sigma_1, \sigma_0, \sigma_1$ -- funkcje rotacji i przesunięć bitowych.
    \end{itemize}
    \item Aktualizacja wartości roboczych $a, b, c, d, e, f, g, h$,
    \item Dodanie wyników do wartości $H_0, \ldots, H_7$.
\end{enumerate}

\textbf{4. Konkatenacja wyników:}

Połączenie wartości $H_0$ do $H_7$ daje 256-bitowy skrót.

\subsection{Zastosowania SHA-256}
\begin{itemize}
    \item \textbf{Podpisy cyfrowe} -- skrót dokumentu jest podpisywany zamiast całego dokumentu,
    \item \textbf{Blockchain i Bitcoin} -- mechanizm proof-of-work, identyfikatory transakcji,
    \item \textbf{Certyfikaty SSL/TLS} -- weryfikacja autentyczności certyfikatów,
    \item \textbf{Sprawdzanie integralności plików} -- porównywanie sum kontrolnych,
    \item \textbf{Przechowywanie haseł} -- haszowanie haseł przed zapisem w bazie danych,
    \item \textbf{HMAC} -- uwierzytelnianie wiadomości z użyciem klucza tajnego.
\end{itemize}

\subsection{Bezpieczeństwo SHA-256}
SHA-256 jest uznawany za bezpieczny algorytm:
\begin{itemize}
    \item Brak znanych praktycznych ataków kolizyjnych,
    \item Złożoność czasowa ataku brutalnego: $2^{256}$ operacji,
    \item Odporność na ataki urodzinowe: $2^{128}$ operacji,
    \item Używany w krytycznych systemach bezpieczeństwa (TLS, IPsec, SSH).
\end{itemize}

\subsection{Implementacja w CryptoLab}
Aplikacja zawiera pełną implementację algorytmu SHA-256 bez użycia zewnętrznych bibliotek.
Implementacja obejmuje:
\begin{itemize}
    \item Preprocessing z padding i dodawaniem długości,
    \item Wszystkie funkcje logiczne ($Ch$, $Maj$, $\Sigma$, $\sigma$),
    \item 64 rundy kompresji dla każdego bloku,
    \item Obsługę wiadomości UTF-8,
    \item Szczegółowe logowanie każdego kroku procesu haszowania.
\end{itemize}

\textbf{Uwaga:} SHA-256 to funkcja jednokierunkowa, więc \textbf{nie ma operacji deszyfrowania}. 
Próba "odszyfrowania" zwraca komunikat informujący o jednokierunkowości funkcji.

\newpage
\section{Wybrane fragmenty kodu}
\subsection{Klasa bazowa algorytmu}
\begin{lstlisting}[language=TypeScript, caption={Klasa abstrakcyjna CryptographicAlgorithm}]
export default class CryptographicAlgorithm {
  name: string;
  description: string;
  category: string;

  encrypt(plaintext: string, key: string): string {
    throw new Error('Metoda encrypt() musi być zaimplementowana');
  }

  decrypt(ciphertext: string, key: string): string {
    throw new Error('Metoda decrypt() musi być zaimplementowana');
  }

  validateKey(key: string): { valid: boolean; error?: string } {
    throw new Error('Metoda validateKey() musi być zaimplementowana');
  }

  getKeyRequirements(): string {
    throw new Error('Metoda getKeyRequirements() musi być zaimplementowana');
  }
}
\end{lstlisting}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/szyfr_cezara.jpg}
    \caption{Ekran główny aplikacji CryptoLab}
    \label{fig:main}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/lista_wyboru.jpg}
    \caption{Lista z możliwością wyboru algorytmu}
    \label{fig:list}
\end{figure}

Rysunek \ref{fig:main} przedstawia ekran główny aplikacji CryptoLab Mobile, a rysunek \ref{fig:list} pokazuje listę dostępnych algorytmów kryptograficznych.
\subsection{Implementacja szyfru Cezara}
\begin{lstlisting}[language=TypeScript, caption={Szczegóły implementacji CaesarCipher}]
export default class CaesarCipher extends CryptographicAlgorithm {
  constructor() {
    super(
      'Szyfr Cezara',
      'Prosty szyfr substytucyjny z przesunięciem',
      'Szyfry klasyczne'
    );
  }

  validateKey(key: string): { valid: boolean; error?: string } {
    const numKey = parseInt(key, 10);
    if (isNaN(numKey) || numKey < 1 || numKey > 25) {
      return { 
        valid: false, 
        error: 'Klucz musi być liczbą od 1 do 25' 
      };
    }
    return { valid: true };
  }

  encrypt(plaintext: string, key: string): string {
    return this._process(plaintext, parseInt(key, 10));
  }

  decrypt(ciphertext: string, key: string): string {
    const shift = 26 - (parseInt(key, 10) % 26);
    return this._process(ciphertext, shift);
  }

  private _process(text: string, shift: number): string {
    return text.split('').map(char => {
      if (/[A-Za-z]/.test(char)) {
        const base = char === char.toUpperCase() ? 65 : 97;
        return String.fromCharCode(
          (char.charCodeAt(0) - base + shift) % 26 + base
        );
      }
      return char;
    }).join('');
  }
}
\end{lstlisting}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/test_cezara.jpg}
    \caption{Test szyfru Cezara}
    \label{fig:testc}
\end{figure}
Rysunek \ref{fig:testc} przedstawia przykładowy test szyfru Cezara w aplikacji CryptoLab Mobile.

\newpage
\subsection{Implementacja szyfru Vigenère'a}
\begin{lstlisting}[language=TypeScript, caption={Fragmenty klasy VigenereCipher}]
export default class VigenereCipher extends CryptographicAlgorithm {
  validateKey(key: string): { valid: boolean; error?: string } {
    if (!key || key.trim().length === 0) {
      return { valid: false, error: 'Klucz nie może być pusty' };
    }
    const hasOnlyLetters = /^[a-zA-Z]+$/.test(key);
    if (!hasOnlyLetters) {
      return { valid: false, error: 'Klucz może zawierać tylko litery' };
    }
    return { valid: true };
  }

  private _process(text: string, key: string, encrypt: boolean): string {
    let result = '';
    let keyIndex = 0;
    const normalizedKey = key.toUpperCase();
    
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (/[A-Za-z]/.test(char)) {
        const base = char === char.toUpperCase() ? 65 : 97;
        const textCode = char.charCodeAt(0) - base;
        const keyCode = normalizedKey.charCodeAt(keyIndex % normalizedKey.length) - 65;
        
        const resultCode = encrypt 
          ? (textCode + keyCode) % 26 
          : (textCode - keyCode + 26) % 26;
        
        result += String.fromCharCode(resultCode + base);
        keyIndex++;
      } else {
        result += char;
      }
    }
    return result;
  }
}
\end{lstlisting}

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/szyfr_vigenerea.jpg}
    \caption{Ekran szyfru Vigenere'a}
    \label{fig:szyfrv}
\end{figure}
Rysunek \ref{fig:szyfrv} przedstawia interfejs użytkownika szyfru Vigenère'a w aplikacji CryptoLab Mobile.
\subsection{Implementacja szyfru z kluczem bieżącym}
\begin{lstlisting}[language=TypeScript, caption={Fragmenty klasy RunningKeyCipher}]
export default class RunningKeyCipher extends CryptographicAlgorithm {
  constructor() {
    super(
      'Szyfr z kluczem bieżącym',
      'Szyfr podobny do Vigenère\'a, ale używający klucza o długości tekstu',
      'Szyfry klasyczne'
    );
  }

  validateKey(key: string): { valid: boolean; error?: string } {
    if (!key || key.trim().length === 0) {
      return { valid: false, error: 'Klucz nie może być pusty' };
    }
    
    // Sprawdź czy klucz zawiera tylko litery
    const hasOnlyLetters = /^[a-zA-Z\s]+$/.test(key);
    if (!hasOnlyLetters) {
      return { valid: false, error: 'Klucz może zawierać tylko litery i spacje (A-Z, a-z)' };
    }
    
    // Policz tylko litery w kluczu
    const keyLettersCount = key.replace(/[^a-zA-Z]/g, '').length;
    if (keyLettersCount < 5) {
      return { 
        valid: false, 
        error: 'Klucz musi zawierać co najmniej 5 liter (może zawierać spacje)' 
      };
    }
    
    return { valid: true };
  }

  getKeyRequirements(): string {
    return 'Tekst (np. fragment książki) - użyto generatora lorem ipsum do stworzenia klucza';
  }
\end{lstlisting}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/Szyfr_z_kb.jpg}
    \caption{Ekran szyfru z kluczem bieżącym}
    \label{fig:szyfrk}
\end{figure}

Rysunek \ref{fig:szyfrk} przedstawia interfejs użytkownika szyfru z kluczem bieżącym w aplikacji CryptoLab Mobile.

\newpage
\subsection{Implementacja szyfru AES}
\begin{lstlisting}[language=TypeScript, caption={Fragmenty klasy AESCipher}]
export default class AESCipher extends CryptographicAlgorithm {
  private mode: AESMode;
  public static readonly DEFAULT_KEY = '2b7e151628aed2a6abf7158809cf4f3c';

  constructor() {
    super(
      'AES (Advanced Encryption Standard)',
      'Symetryczny szyfr blokowy z możliwością wyboru trybu (ECB, CBC, CTR)',
      'Szyfry symetryczne'
    );
    this.mode = 'ECB'; // Domyślny tryb
  }

  // Ustawia tryb pracy AES
  setMode(mode: AESMode): void {
    this.mode = mode;
  }

  validateKey(key: string): { valid: boolean; error?: string } {
    if (!key || key.trim().length === 0) {
      return { valid: false, error: 'Klucz nie może być pusty' };
    }

    // Sprawdź czy klucz jest w formacie hex
    const hexPattern = /^[0-9a-fA-F]+$/;
    if (!hexPattern.test(key)) {
      return { 
        valid: false, 
        error: 'Klucz musi być ciągiem znaków szesnastkowych (0-9, A-F)' 
      };
    }

    // Klucz musi mieć długość 32, 48 lub 64 znaków hex
    if (key.length !== 32 && key.length !== 48 && key.length !== 64) {
      return {
        valid: false,
        error: 'Klucz musi mieć długość 32 (AES-128), 48 (AES-192) lub 64 (AES-256)'
      };
    }

    return { valid: true };
  }

  getKeyRequirements(): string {
    return `Tryb: ${this.mode} | Klucz hex: 32 znaki (AES-128), 
      48 (AES-192) lub 64 (AES-256)`;
  }

  // Główne metody szyfrowania wykorzystujące wybrany tryb
  encrypt(plaintext: string, key: string): string {
    if (this.mode === 'ECB') {
      return this.encryptECB(plaintext, key);
    } else if (this.mode === 'CBC') {
      return this.encryptCBC(plaintext, key);
    } else if (this.mode === 'CTR') {
      return this.encryptCTR(plaintext, key);
    }
    throw new Error(`Tryb ${this.mode} nie jest obsługiwany`);
  }
}
\end{lstlisting}

\subsection{Implementacja szyfru RSA}
\begin{lstlisting}[language=TypeScript, caption={Fragmenty klasy RSACipher}]
export default class RSACipher extends CryptographicAlgorithm {
  private keyPair: RSAKeyPair | null = null;

  constructor() {
    super(
      'RSA (Rivest-Shamir-Adleman)',
      'Asymetryczny algorytm kryptograficzny z kluczem publicznym i prywatnym',
      'Kryptografia asymetryczna'
    );
  }

  // Generuje pare kluczy RSA
  generateKeyPair(bitSize: number = 512): RSAKeyPair {
    const min = bitSize === 512 ? 100 : 50;
    const max = bitSize === 512 ? 300 : 100;
    
    // Generuj dwie rozne liczby pierwsze
    const p = generatePrime(min, max);
    let q = generatePrime(min, max);
    while (q === p) {
      q = generatePrime(min, max);
    }

    const n = p * q;  // Modul
    const phi = (p - 1) * (q - 1);  // Funkcja Eulera

    // Wybierz e (wykladnik publiczny)
    let e = 65537;
    if (e >= phi) e = 17;
    while (gcd(e, phi) !== 1) {
      e++;
    }

    // Oblicz d (wykladnik prywatny)
    const d = modInverse(e, phi);

    this.keyPair = {
      publicKey: { e, n },
      privateKey: { d, n }
    };

    return this.keyPair;
  }

  encrypt(plaintext: string, key: string): string {
    const [e, n] = key.split(',').map(p => parseInt(p.trim(), 10));

    const encrypted: number[] = [];
    for (let i = 0; i < plaintext.length; i++) {
      const charCode = plaintext.charCodeAt(i);
      
      // Szyfrowanie: c = m^e mod n
      const encryptedChar = Number(
        modPow(BigInt(charCode), BigInt(e), BigInt(n))
      );
      encrypted.push(encryptedChar);
    }

    return encrypted.join(' ');
  }

  decrypt(ciphertext: string, key: string): string {
    const [d, n] = key.split(',').map(p => parseInt(p.trim(), 10));
    const encryptedNumbers = ciphertext.trim().split(/\s+/)
      .map(s => parseInt(s, 10));
    
    const decrypted: string[] = [];
    for (const encryptedChar of encryptedNumbers) {
      // Deszyfrowanie: m = c^d mod n
      const decryptedChar = Number(
        modPow(BigInt(encryptedChar), BigInt(d), BigInt(n))
      );
      decrypted.push(String.fromCharCode(decryptedChar));
    }

    return decrypted.join('');
  }
}
\end{lstlisting}
\newpage
\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/RSA.jpg}
    \caption{Ekran szyfru RSA}
    \label{fig:szyfrrsa}
\end{figure}
Rysunek \ref{fig:szyfrrsa} przedstawia interfejs użytkownika szyfru RSA w aplikacji CryptoLab Mobile.
\newpage
\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/RSA_keygen.jpg}
    \caption{Generowanie kluczy RSA}
    \label{fig:rsakeygen}
\end{figure}
Rysunek \ref{fig:rsakeygen} przedstawia ekran generowania kluczy RSA w aplikacji CryptoLab Mobile.
\newpage
\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/RSA_szyfrowanie.jpg}
    \caption{Test szyfru RSA}
    \label{fig:testrsa}
\end{figure}
Rysunek \ref{fig:testrsa} przedstawia przykładowy test szyfru RSA w aplikacji CryptoLab Mobile.
\newpage
\begin{figure}
    \centering
    \includegraphics[width=0.3\textwidth]{img/RSA_deszyfr.jpg}
    \caption{Deszyfrowanie w szyfrze RSA}
    \label{fig:deszyfrrsa}
\end{figure}
Rysunek \ref{fig:deszyfrrsa} przedstawia ekran deszyfrowania w szyfrze RSA w aplikacji CryptoLab Mobile.

\newpage
\subsection{Implementacja algorytmu ElGamal}
\begin{lstlisting}[language=TypeScript, caption={Fragmenty klasy ElGamalCipher}]
export default class ElGamalCipher extends CryptographicAlgorithm {
  // Generowanie kluczy
  generateKeyPair(): ElGamalKeyPair {
    // 1. Wybierz duza liczbe pierwsza p
    const p = generatePrime(300, 1000);
    
    // 2. Znajdz generator g
    const g = findPrimitiveRoot(p);
    
    // 3. Wybierz losowy klucz prywatny x
    const x = Math.floor(Math.random() * (p - 2)) + 2;
    
    // 4. Oblicz klucz publiczny y = g^x mod p
    const y = modPow(BigInt(g), BigInt(x), BigInt(p));

    return {
      publicKey: { p: p.toString(), g: g.toString(), y: y.toString() },
      privateKey: { x: x.toString(), p: p.toString() }
    };
  }

  encrypt(plaintext: string, key: string): string {
    const [p, g, y] = key.split(',').map(n => BigInt(n));
    const encryptedPairs: string[] = [];

    for (let i = 0; i < plaintext.length; i++) {
      const m = BigInt(plaintext.charCodeAt(i));
      
      // 1. Wybierz losowe k (klucz efemeryczny)
      let k: bigint;
      do {
        k = BigInt(Math.floor(Math.random() * (Number(p) - 2)) + 1);
      } while (gcd(k, p - 1n) !== 1n);

      // 2. Oblicz a = g^k mod p
      const a = modPow(g, k, p);

      // 3. Oblicz b = (y^k * m) mod p
      const b = (modPow(y, k, p) * m) % p;

      encryptedPairs.push(`${a}:${b}`);
    }
    return encryptedPairs.join(' ');
  }
}
\end{lstlisting}

\subsection{Implementacja algorytmu ECDH}
\begin{lstlisting}[language=TypeScript, caption={Fragmenty klasy ECDHAlgorithm}]
export default class ECDHAlgorithm extends CryptographicAlgorithm {
  // Dodawanie punktow na krzywej eliptycznej
  private addPoints(P: Point, Q: Point): Point {
    if (P.isInfinity) return Q;
    if (Q.isInfinity) return P;
    
    let m: bigint;
    if (P.x === Q.x && P.y === Q.y) {
      // Podwojenie punktu: m = (3x^2 + a) / (2y)
      const num = (3n * P.x * P.x + CURVE.a) % CURVE.p;
      const den = (2n * P.y) % CURVE.p;
      m = (num * this.modInverse(den, CURVE.p)) % CURVE.p;
    } else {
      // Dodawanie: m = (y2 - y1) / (x2 - x1)
      const num = (Q.y - P.y) % CURVE.p;
      const den = (Q.x - P.x) % CURVE.p;
      m = (num * this.modInverse(den, CURVE.p)) % CURVE.p;
    }
    
    // Obliczanie x3, y3...
    // ...
    return { x: x3, y: y3, isInfinity: false };
  }

  encrypt(plaintext: string, key: string): string {
    // key to klucz publiczny odbiorcy (Q)
    const [qx, qy] = key.split(',').map(c => BigInt(c));
    const Q: Point = { x: qx, y: qy, isInfinity: false };

    // 1. Wygeneruj tymczasowa pare kluczy (k, R)
    const k = BigInt(Math.floor(Math.random() * (Number(CURVE.p) - 2)) + 1);
    const R = this.multiplyPoint(k, CURVE.G); // R = k * G
    
    // 2. Oblicz wspolny sekret S = k * Q
    const S = this.multiplyPoint(k, Q);

    // 3. Uzyj wspolrzednej x punktu S jako klucza symetrycznego
    const symmetricKey = Number(S.x);

    // 4. Szyfruj wiadomosc (XOR)
    // ...
    
    return `${R.x},${R.y}|${ciphertextBody}`;
  }
}
\end{lstlisting}

\subsection{Implementacja funkcji SHA-256}
\begin{lstlisting}[language=TypeScript, caption={Fragmenty klasy SHA256Hash}]
export default class SHA256Hash extends CryptographicAlgorithm {
  // Stale K (pierwsze 32 bity ulamkowych czesci 
  // szescianowych pierwiastkow pierwszych 64 liczb pierwszych)
  private K: number[] = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    // ... 60 wiecej wartosci ...
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ];

  // Wartosci poczatkowe H (pierwiastki kwadratowe 
  // pierwszych 8 liczb pierwszych)
  private H: number[] = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];

  encrypt(plaintext: string, key: string = ''): string {
    this.logStep('SHA-256 Hash Process Started', plaintext);
    
    const bytes = this.stringToBytes(plaintext);
    const hash = this.sha256(bytes);
    const hexHash = this.bytesToHex(hash);
    
    this.logStep('SHA-256 Hash Generated', plaintext, hexHash);
    return hexHash;
  }

  // Glowny algorytm SHA-256
  private sha256(message: number[]): number[] {
    const preprocessed = this.preprocess(message);
    const H = [...this.H];

    // Przetwarzanie kazdego bloku 512-bitowego
    for (let i = 0; i < preprocessed.length; i += 16) {
      const block = preprocessed.slice(i, i + 16);
      const W = this.prepareSchedule(block);
      let [A, B, C, D, E, F, G, H_temp] = [...H];

      // 64 rundy
      for (let t = 0; t < 64; t++) {
        const T1 = H_temp + this.Sigma1(E) + 
                   this.Ch(E, F, G) + this.K[t] + W[t];
        const T2 = this.Sigma0(A) + this.Maj(A, B, C);
        
        H_temp = G; G = F; F = E;
        E = (D + T1) >>> 0;
        D = C; C = B; B = A;
        A = (T1 + T2) >>> 0;
      }

      // Aktualizacja wartosci H
      H[0] = (H[0] + A) >>> 0;
      H[1] = (H[1] + B) >>> 0;
      // ... pozostale ...
    }
    return this.hashToBytes(H);
  }

  // Funkcje logiczne SHA-256
  private Ch(x: number, y: number, z: number): number {
    return (x & y) ^ (~x & z);
  }

  private Maj(x: number, y: number, z: number): number {
    return (x & y) ^ (x & z) ^ (y & z);
  }

  private Sigma0(x: number): number {
    return this.rightRotate(x, 2) ^ 
           this.rightRotate(x, 13) ^ 
           this.rightRotate(x, 22);
  }

  private Sigma1(x: number): number {
    return this.rightRotate(x, 6) ^ 
           this.rightRotate(x, 11) ^ 
           this.rightRotate(x, 25);
  }
}
\end{lstlisting}

\newpage
\section{Podsumowanie}

\subsection{Szyfr Cezara}
Szyfr Cezara należy do najstarszych i najprostszych technik szyfrowania. 
Jego główna idea polega na przesuwaniu liter alfabetu o ustaloną liczbę pozycji. 
Mimo że w praktyce jest to jedynie przykład historyczny, implementacja szyfru pozwala lepiej zrozumieć podstawowe mechanizmy kryptografii, takie jak klucz, szyfrowanie i deszyfrowanie.

\textbf{Zalety:}
\begin{itemize}
    \item bardzo prosta implementacja,
    \item szybkie działanie,
    \item dobre ćwiczenie dydaktyczne.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item niska odporność na ataki kryptograficzne,
    \item atak brute-force łatwe przełamuje szyfr w sekundach,
    \item podatny na analizę częstotliwości.
\end{itemize}

\subsection{Szyfr Vigenère'a}
Szyfr Vigenère'a to znacznie bardziej zaawansowany szyfr polialfabetyczny. 
Przez wieki uważany był za niezniszczalny, 
ale ostatecznie został przełamany dzięki analizie częstotliwości długości okresu.

\textbf{Zalety:}
\begin{itemize}
    \item znacznie bardziej bezpieczny niż szyfr Cezara,
    \item odporne na prostą analizę częstotliwości,
    \item wykorzystuje koncepcję słowa-klucza, co jest intuicyjne.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item niska odporność na ataki kryptograficzne (możliwy atak siłowy poprzez sprawdzenie wszystkich przesunięć),
    \item brak zastosowania we współczesnych systemach bezpieczeństwa,
    \item szyfr działa jedynie na ograniczonym zbiorze znaków (najczęściej alfabet łaciński).
\end{itemize}

\newpage
\subsection{Szyfr z kluczem bieżącym}
Szyfr z kluczem bieżącym to krok w kierunku szyfrowania jednorazowego.

\textbf{Zalety:}
\begin{itemize}
    \item gdy klucz jest losowy i używany raz -- teoretycznie nie do złamania,
    \item koncepcja zbliża się do rzeczywistego bezpieczeństwa informacyjnego,
    \item edukacyjnie pokazuje znaczenie losowości klucza.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item wymaga przechowywania bardzo długich kluczy,
    \item wymaga absolutnej losowości i jednorazowego użycia,
    \item niepraktyczne w większości rzeczywistych zastosowań.
\end{itemize}

\subsection{Szyfr AES}
AES (Advanced Encryption Standard) to nowoczesny szyfr symetryczny, który stanowi podstawę współczesnej kryptografii. 
W przeciwieństwie do szyfrów klasycznych, AES jest używany w realnych systemach bezpieczeństwa na całym świecie.

\textbf{Zalety:}
\begin{itemize}
    \item wysoki poziom bezpieczeństwa -- odporny na wszystkie znane praktyczne ataki,
    \item elastyczność -- obsługa trzech długości kluczy (128, 192, 256 bitów),
    \item różne tryby pracy (ECB, CBC, CTR) dostosowane do różnych zastosowań,
    \item szybkie działanie przy zachowaniu bezpieczeństwa,
    \item szeroko stosowany i przetestowany w praktyce,
    \item standaryzowany przez NIST i akceptowany globalnie.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item znacznie bardziej złożona implementacja niż szyfry klasyczne,
    \item wymaga zrozumienia trybów pracy i ich właściwości,
    \item tryb ECB jest niebezpieczny i nie powinien być stosowany w praktyce,
    \item wymaga bezpiecznego zarządzania kluczami i wektorami inicjalizującymi (IV),
    \item jako szyfr symetryczny, wymaga bezpiecznego przekazania klucza obu stronom komunikacji.
\end{itemize}

\textbf{Zastosowanie edukacyjne:}
\begin{itemize}
    \item pokazuje różnicę między kryptografią klasyczną a nowoczesną,
    \item wprowadza pojęcia: tryby pracy, padding, wektor inicjalizujący (IV),
    \item demonstruje znaczenie wyboru odpowiedniego trybu pracy,
    \item ilustruje jak działa rzeczywiste szyfrowanie stosowane w praktyce.
\end{itemize}

\subsection{Szyfr RSA}
RSA to przełomowy algorytm kryptografii asymetrycznej, który rozwiązał fundamentalny problem 
bezpiecznej wymiany kluczy i wprowadził koncepcję kluczy publicznych.

\textbf{Zalety:}
\begin{itemize}
    \item rozwiązuje problem wymiany kluczy -- nie wymaga bezpiecznego kanału,
    \item umożliwia podpisy cyfrowe i uwierzytelnianie,
    \item bezpieczny przy odpowiednio dużych kluczach (2048+ bitów),
    \item szeroko stosowany i przetestowany w praktyce,
    \item fundamentalna technologia dla PKI (Public Key Infrastructure),
    \item umożliwia szyfrowanie hybrydowe w połączeniu z AES.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item znacznie wolniejszy niż algorytmy symetryczne (100-1000x),
    \item wymaga dużych kluczy (2048-4096 bitów) dla bezpieczeństwa,
    \item zagrożenie ze strony komputerów kwantowych,
    \item złożona implementacja -- łatwo popełnić błędy bezpieczeństwa,
    \item nie nadaje się do szyfrowania dużych ilości danych.
\end{itemize}

\textbf{Zastosowanie edukacyjne:}
\begin{itemize}
    \item wprowadza fundamentalną różnicę między kryptografią symetryczną i asymetryczną,
    \item pokazuje matematyczne podstawy bezpieczeństwa (teoria liczb),
    \item ilustruje koncepcję klucza publicznego i prywatnego,
    \item demonstruje praktyczne zastosowania: wymiana kluczy, podpisy cyfrowe,
    \item pozwala zrozumieć jak działa HTTPS, SSH i inne protokoły bezpieczeństwa.
\end{itemize}

\textbf{RSA w praktyce:}
W rzeczywistych systemach RSA rzadko jest używany do bezpośredniego szyfrowania danych. 
Zamiast tego stosuje się \textbf{szyfrowanie hybrydowe}:
\begin{enumerate}
    \item Generowany jest losowy klucz AES (symetryczny),
    \item Dane szyfrowane są szybkim algorytmem AES,
    \item Klucz AES szyfrowany jest wolnym, ale bezpiecznym RSA,
    \item Przesyłany jest zaszyfrowany klucz AES + zaszyfrowane dane.
\end{enumerate}

To połączenie zapewnia zarówno bezpieczeństwo RSA, jak i szybkość AES.

\subsection{Algorytm ElGamal}
ElGamal to alternatywa dla RSA, oparta na innym problemie matematycznym (logarytm dyskretny).

\textbf{Zalety:}
\begin{itemize}
    \item bezpieczeństwo oparte na dobrze zbadanym problemie matematycznym,
    \item niedeterministyczność szyfrowania (ten sam tekst szyfrowany jest inaczej za każdym razem), co utrudnia kryptoanalizę.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item szyfrogram jest dwukrotnie dłuższy od wiadomości jawnej (para liczb dla każdego bloku),
    \item wolniejsze działanie niż RSA (więcej potęgowań).
\end{itemize}

\subsection{Protokół ECDH}
Kryptografia krzywych eliptycznych (ECC) to przyszłość bezpiecznej komunikacji.

\textbf{Zalety:}
\begin{itemize}
    \item bardzo wysoki poziom bezpieczeństwa przy krótkich kluczach (256-bit ECC $\approx$ 3072-bit RSA),
    \item szybsze obliczenia i mniejsze zużycie energii (ważne w urządzeniach mobilnych),
    \item mniejsze wymagania pamięciowe.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item skomplikowana matematyka i trudniejsza implementacja,
    \item wrażliwość na słabe generatory liczb losowych.
\end{itemize}

\subsection{Funkcja SHA-256}
SHA-256 jest kryptograficzną funkcją skrótu o fundamentalnym znaczeniu dla bezpieczeństwa.

\textbf{Zalety:}
\begin{itemize}
    \item \textbf{jednokierunkowość} -- niemożliwe odtworzenie oryginalnej wiadomości,
    \item \textbf{deterministyczność} -- ten sam wejście zawsze daje ten sam wynik,
    \item \textbf{efekt lawiny} -- minimalna zmiana wejścia drastycznie zmienia skrót,
    \item \textbf{odporność na kolizje} -- praktycznie niemożliwe znalezienie dwóch wiadomości o tym samym skrócie,
    \item \textbf{szybkość} -- wydajne obliczenia na nowoczesnym sprzęcie,
    \item \textbf{wszechstronność} -- używana w blockchain, podpisach cyfrowych, TLS, weryfikacji integralności.
\end{itemize}

\textbf{Wady i ograniczenia:}
\begin{itemize}
    \item nie nadaje się do haszowania haseł bez dodatkowych mechanizmów (salt, iteracje),
    \item brak mechanizmu weryfikacji autentyczności (do tego służy HMAC),
    \item teoretycznie podatna na ataki kwantowe (w odległej przyszłości).
\end{itemize}

\textbf{Zastosowania w praktyce:}
\begin{itemize}
    \item \textbf{Bitcoin i blockchain} -- proof-of-work, identyfikacja bloków i transakcji,
    \item \textbf{Podpisy cyfrowe} -- haszowanie dokumentów przed podpisaniem,
    \item \textbf{Certyfikaty SSL/TLS} -- weryfikacja integralności i autentyczności,
    \item \textbf{Git} -- identyfikacja commitów i obiektów (choć Git używa SHA-1),
    \item \textbf{Sumy kontrolne} -- weryfikacja pobranych plików.
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/sha-256.jpg}
    \caption{Ekran funkcji SHA-256}
    \label{fig:sha256}
\end{figure}
Rysunek \ref{fig:sha256} przedstawia interfejs użytkownika funkcji SHA-256 w aplikacji CryptoLab Mobile.

\section{System logowania operacji}
\label{sec:logging}

Aplikacja CryptoLab Mobile zawiera zaawansowany system logowania, 
który rejestruje wszystkie operacje kryptograficzne wykonywane przez użytkownika. 
System ten służy celom edukacyjnym i analitycznym, 
umożliwiając śledzenie historii operacji oraz analizę kroków algorytmów.

\subsection{Architektura systemu logowania}

System logowania składa się z trzech głównych komponentów:

\begin{description}
    \item[\textbf{LogManager.ts}] 
    Singleton zarządzający całym systemem logowania. 
    Odpowiada za:
    \begin{itemize}
        \item rozpoczynanie i kończenie operacji kryptograficznych,
        \item rejestrowanie kroków pośrednich w algorytmach,
        \item zapisywanie logów w pamięci trwałej (AsyncStorage),
        \item powiadamianie komponentów UI o zmianach w logach,
        \item zarządzanie liczbą przechowywanych logów (maksymalnie 100).
    \end{itemize}

    \item[\textbf{LogTypes.ts}] 
    Definicje typów TypeScript dla systemu logowania:
    \begin{itemize}
        \item \texttt{LogStep} -- pojedynczy krok w algorytmie,
        \item \texttt{CryptoLogEntry} -- kompletny wpis logu operacji,
        \item \texttt{LogFilter} -- filtry wyszukiwania logów,
        \item \texttt{LogStats} -- statystyki użycia algorytmów.
    \end{itemize}

    \item[\textbf{LogsViewer.tsx}] 
    Komponent React Native wyświetlający historię operacji. 
    Funkcjonalności:
    \begin{itemize}
        \item wyświetlanie listy wszystkich operacji z timestampami,
        \item filtrowanie logów (wszystkie/szyfrowanie/deszyfrowanie),
        \item podgląd szczegółów operacji krok po kroku,
        \item eksport wyników do schowka,
        \item usuwanie pojedynczych logów lub czyszczenie całej historii,
        \item wyświetlanie statystyk (liczba operacji, najczęściej używany algorytm).
    \end{itemize}
\end{description}

\subsection{Rejestrowane informacje}

Każdy wpis logu (\texttt{CryptoLogEntry}) zawiera:

\begin{itemize}
    \item \textbf{Metadane:} ID, timestamp, nazwa algorytmu, typ operacji (encrypt/decrypt)
    \item \textbf{Dane operacji:} tekst wejściowy, tekst wyjściowy, klucz (maskowany dla bezpieczeństwa)
    \item \textbf{Parametry:} tryb pracy (dla AES), długość klucza
    \item \textbf{Status:} sukces/błąd, komunikat błędu (jeśli wystąpił)
    \item \textbf{Wydajność:} czas wykonania operacji w milisekundach
    \item \textbf{Kroki algorytmu:} szczegółowy przebieg operacji z danymi pośrednimi
\end{itemize}

\subsection{Kroki algorytmu}

System loguje szczegółowe kroki wykonywania algorytmów (\texttt{LogStep}), co pozwala użytkownikom:
\begin{itemize}
    \item zrozumieć jak działa algorytm krok po kroku,
    \item zobaczyć transformacje danych na każdym etapie,
    \item debugować problemy z szyfrowaniem/deszyfrowaniem,
    \item analizować różnice między algorytmami.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/logs.jpg}
    \caption{Ekran przeglądu logów}
    \label{fig:logs}
\end{figure}
Rysunek \ref{fig:logs} przedstawia ekran przeglądu logów w aplikacji CryptoLab Mobile.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/logs_all.jpg}
    \includegraphics[width=0.3\textwidth]{img/logs_all_end.jpg}
    \caption{Szczegółowe logi dla przykładowej operacji}
    \label{fig:logdetails}
\end{figure}
Rysunek \ref{fig:logdetails} przedstawia szczegółowe logi dla przykładowej operacji szyfrowania w aplikacji CryptoLab Mobile.
\subsection{Bezpieczeństwo kluczy}

System automatycznie maskuje klucze w logach:
\begin{itemize}
    \item Krótkie klucze (do 10 znaków) -- wyświetlane w całości
    \item Średnie klucze (11-30 znaków) -- maskowane środkowe znaki
    \item Długie klucze (powyżej 30 znaków) -- pokazane tylko pierwsze i ostatnie 10 znaków
    \item Klucze RSA -- maskowane dla bezpieczeństwa
\end{itemize}

\subsection{Statystyki}

LogManager oblicza i udostępnia statystyki użycia:
\begin{itemize}
    \item łączna liczba operacji szyfrowania i deszyfrowania,
    \item najczęściej używany algorytm,
    \item wskaźnik sukcesu operacji,
    \item średni czas wykonania operacji.
\end{itemize}

\subsection{Zastosowanie edukacyjne}

System logowania ma kluczowe znaczenie edukacyjne:
\begin{itemize}
    \item pozwala studentom zobaczyć jak algorytmy działają \textit{od środka},
    \item umożliwia porównanie kroków różnych algorytmów,
    \item pomaga zrozumieć złożoność obliczeniową,
    \item wspiera analizę błędów i debugowanie,
    \item dostarcza danych do tworzenia raportów i prezentacji.
\end{itemize}


\section{Changelog}
\label{sec:changelog}
\begin{itemize}
    \item \textbf{14.10.2025} Implementacja szyfru Cezara (szyfrowanie, deszyfrowanie, walidacja klucza) oraz podstawowe GUI.
    \item \textbf{20.10.2025} Dodanie szyfru Vigenère'a i szyfru z kluczem bieżącym. \newline Ulepszenie interfejsu użytkownika. \newline 
    Implementacja AlgorithmRegistry z wzorcem Singleton. 
    \newline Ulepszenie walidacji kluczy z szczegółowymi komunikatami o błędach.
    \item \textbf{28.10.2025} Implementacja szyfru AES (Advanced Encryption Standard) z obsługą trzech trybów pracy: ECB, CBC, CTR. \newline
    Wsparcie dla kluczy AES-128, AES-192 i AES-256. \newline
    Dodanie paddingu PKCS\#7 i obsługi wektorów inicjalizujących (IV). \newline
    Pełna implementacja algorytmu AES bez użycia zewnętrznych bibliotek kryptograficznych.
    \item \textbf{16.11.2025} Implementacja algorytmu RSA (Rivest-Shamir-Adleman) -- pierwszy algorytm kryptografii asymetrycznej w aplikacji. \newline
    Generowanie par kluczy publiczny/prywatny z losowymi liczbami pierwszymi. \newline
    Implementacja algorytmu Euklidesa, rozszerzonego algorytmu Euklidesa i szybkiego potęgowania modularnego. \newline
    Dodanie kategorii "Kryptografia asymetryczna" w rejestrze algorytmów. \newline
    Wprowadzenie koncepcji szyfrowania hybrydowego w dokumentacji. \newline
    \textbf{Dodanie GUI do generowania kluczy RSA} -- przycisk "Generuj klucze" z modalem wyświetlającym klucz publiczny i prywatny, możliwość kopiowania i bezpośredniego użycia kluczy w aplikacji.
    \item \textbf{24.11.2025} Implementacja zaawansowanego systemu logowania operacji kryptograficznych. \newline
    Utworzenie \texttt{LogManager} z wzorcem Singleton do centralnego zarządzania logami. \newline
    Dodanie komponentu \texttt{LogsViewer} do wyświetlania historii operacji z interfejsem użytkownika. \newline
    Rejestrowanie szczegółowych kroków algorytmów dla celów edukacyjnych. \newline
    Przechowywanie logów w AsyncStorage z limitem 100 wpisów. \newline
    Funkcje filtrowania, usuwania i eksportu logów. \newline
    Automatyczne maskowanie kluczy dla bezpieczeństwa. \newline
    Statystyki użycia algorytmów (liczba operacji, najczęściej używany algorytm, czas wykonania). \newline
    Integracja systemu logowania ze wszystkimi algorytmami (Cezar, Vigenère, Running Key, AES, RSA).
    \item \textbf{01.12.2025} Implementacja algorytmu ElGamal oraz protokołu ECDH (Elliptic Curve Diffie-Hellman). \newline
    Dodanie obsługi problemu logarytmu dyskretnego w ElGamal. \newline
    Implementacja operacji na krzywych eliptycznych (dodawanie punktów, mnożenie skalarne) dla ECDH. \newline
    Demonstracja schematu ECIES (Elliptic Curve Integrated Encryption Scheme). \newline
    Rozszerzenie dokumentacji o nowe algorytmy asymetryczne.
    \item \textbf{07.12.2025} Implementacja funkcji skrótu SHA-256. \newline
    Rejestrowanie szczegółowych kroków funkcji skrótu w systemie logowania. \newline
    Dodanie zastosowań SHA-256 w praktyce (blockchain, podpisy cyfrowe). \newline
    Ulepszenie dokumentacji o funkcje skrótu i ich znaczenie w bezpieczeństwie.
\end{itemize}


\end{document}
