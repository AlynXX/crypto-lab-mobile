\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}

\geometry{margin=2.5cm}

% Styl listingów
\lstset{
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{blue},
  commentstyle=\color{green!50!black},
  stringstyle=\color{red},
  showstringspaces=false,
  breaklines=true,
  frame=single
}

\title{Dokumentacja Projektu CryptoLab Mobile}
\author{Agnieszka Ryś}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

\newpage
\section{Cel projektu}
Celem aplikacji \textbf{CryptoLab Mobile} jest edukacja w zakresie kryptografii. 
Aplikacja mobilna pozwala szyfrować i deszyfrować teksty oraz pliki \texttt{.txt}, 
sprawdzać poprawność kluczy oraz eksportować wyniki. 
Aplikacja implementuje zarówno klasyczne szyfry historyczne (Cezara, Vigenère'a, szyfr z kluczem bieżącym), 
nowoczesny standard szyfrowania symetrycznego AES (Advanced Encryption Standard),
jak i przełomowy algorytm kryptografii asymetrycznej RSA (Rivest-Shamir-Adleman).
Wszystkie algorytmy są implementowane ręcznie, bez użycia gotowych bibliotek kryptograficznych, 
co pozwala na głębsze zrozumienie ich działania i różnic między kryptografią symetryczną a asymetryczną.

\section{Podstawy kryptografii}

Kryptografia to ochrona informacji poprzez przekształcanie jej w formę nieczytelną. W kryptografii \textbf{symetrycznej} ten sam klucz służy do szyfrowania i deszyfrowania - cechuje się wysoką szybkością, ale wymaga bezpiecznej wymiany klucza.

Aplikacja implementuje szyfry klasyczne (Cezara, Vigenère'a, z kluczem bieżącym) oraz nowoczesne (AES, RSA, ElGamal, ECDH, SHA-256, podpis elektroniczny). Choć klasyczne szyfry nie zapewniają dziś bezpieczeństwa, stanowią doskonałe narzędzie dydaktyczne do zrozumienia podstawowych pojęć: klucza, przestrzeni kluczy, analizy częstości i ataków brute-force.

\textbf{Ewolucja: od klasyki do nowoczesności}
\begin{itemize}
    \item \textbf{Szyfry klasyczne} - proste podstawienia (Cezar: przesunięcie liter o stałą wartość)
    \item \textbf{AES} - szyfr blokowy 128-bit z trybami ECB/CBC/CTR, odporny na znane ataki
    \item \textbf{RSA/ECC} - kryptografia asymetryczna z parą kluczy publiczny/prywatny
    \item \textbf{SHA-256} - funkcja skrótu jednokierunkowa do integralności danych
    \item \textbf{Podpis cyfrowy} - RSA+SHA256 do autentykacji i niezaprzeczalności
\end{itemize}

\newpage
\section{Technologie wykorzystane w projekcie}

\begin{description}
    \item[\textbf{React Native + Expo}] 
    Główna platforma wykorzystana do tworzenia aplikacji mobilnych. 
    React Native umożliwia budowanie natywnych aplikacji na systemy Android i iOS, wykorzystując składnię zbliżoną do Reacta. 
    Expo zostało użyte jako narzędzie wspierające proces developmentu – upraszcza konfigurację środowiska, przyspiesza testowanie na urządzeniach mobilnych i zapewnia dostęp do bogatego ekosystemu bibliotek.

    \item[\textbf{TypeScript}] 
    Nadzbiór JavaScriptu wprowadzający system typów. 
    Zastosowanie TypeScriptu pozwoliło na: 
    \begin{itemize}
        \item wcześniejsze wykrywanie błędów podczas kompilacji,
        \item lepszą kontrolę nad strukturą danych i interfejsami,
        \item zwiększoną czytelność oraz przewidywalność kodu,
    \end{itemize}

    \item[\textbf{Expo Document Picker, File System, Vector Icons}] 
    Dodatkowe biblioteki środowiska Expo: 
    \begin{itemize}
        \item \texttt{expo-document-picker} – umożliwia wybór plików z pamięci urządzenia, 
        \item \texttt{expo-file-system} – zapewnia dostęp do systemu plików (zapisywanie, odczyt, usuwanie plików),
        \item \texttt{expo-vector-icons} – biblioteka ikon pozwalająca wzbogacić interfejs użytkownika.
    \end{itemize}

    \item[\textbf{Git}] 
    System kontroli wersji użyty do zarządzania historią kodu. 
    Pozwolił na prowadzenie szczegółowego changelogu, śledzenie postępów w projekcie oraz łatwe zarządzanie zmianami w kodzie źródłowym.

    \item[\textbf{LaTeX}] 
    System składu tekstu wykorzystany do przygotowania dokumentacji. 
    Umożliwia on: 
    \begin{itemize}
        \item zachowanie spójności formatowania,
        \item wygodne dodawanie fragmentów kodu źródłowego i zrzutów ekranu,
        \item automatyczne generowanie spisów treści i numeracji.
    \end{itemize}
\end{description}

\newpage

\section{Architektura systemu}

\subsection{Wzorzec projektowy}
Aplikacja wykorzystuje \textbf{Strategy Pattern} dla algorytmów kryptograficznych. 
Każdy algorytm dziedziczy z klasy abstrakcyjnej \texttt{CryptographicAlgorithm} i implementuje metody:
\begin{itemize}
    \item \texttt{encrypt(plaintext, key)} - szyfruje tekst,
    \item \texttt{decrypt(ciphertext, key)} - deszyfruje tekst,
    \item \texttt{validateKey(key)} - sprawdza poprawność klucza,
    \item \texttt{getKeyRequirements()} - zwraca opis wymagań dla klucza.
\end{itemize}

Wszystkie algorytmy zarejestrowane są w \texttt{AlgorithmRegistry} (Singleton Pattern), 
co umożliwia łatwe dodawanie nowych szyfrów bez modyfikacji głównej aplikacji.

\subsection{Komponenty główne}
\begin{itemize}
    \item \textbf{App.tsx} - główny komponent aplikacji, obsługuje interfejs użytkownika,
    \item \textbf{AlgorithmSidebar.tsx} - boczny panel z listą dostępnych algorytmów,
    \item \textbf{LogsViewer.tsx} - komponent wyświetlania historii operacji kryptograficznych,
    \item \textbf{AlgorithmRegistry.ts} - rejestr i zarządzanie algorytmami,
    \item \textbf{CryptographicAlgorithm.ts} - klasa bazowa dla wszystkich algorytmów,
    \item \textbf{LogManager.ts} - menadżer logów z wzorcem Singleton,
    \item \textbf{fileUtils.ts} - funkcje do obsługi operacji na plikach.
\end{itemize}

\newpage
\section{Struktura projektu}
\begin{lstlisting}
crypto-lab-mobile/
├── App.tsx                          (glowny komponent)
├── package.json                     (zalezności projektu)
├── tsconfig.json                    (konfiguracja TypeScriptu)
├── app.json                         (konfiguracja Expo)
├── src/
│   ├── algorithms/
│   │   ├── CryptographicAlgorithm.ts   (klasa bazowa)
│   │   ├── CaesarCipher.ts             (szyfr Cezara)
│   │   ├── VigenereCipher.ts           (szyfr Vigenere'a)
│   │   ├── RunningKeyCipher.ts         (szyfr z kluczem biezacym)
│   │   ├── AESCipher.ts                (szyfr AES)
│   │   ├── RSACipher.ts                (szyfr RSA)
│   │   └── AlgorithmRegistry.ts        (rejestr algorytmow)
│   ├── components/
│   │   ├── AlgorithmSidebar.tsx        (panel z algorytmami)
│   │   └── LogsViewer.tsx              (wyswietlanie logow)
│   ├── types/
│   │   └── LogTypes.ts                 (typy dla systemu logow)
│   └── utils/
│       ├── fileUtils.ts                (obsluga plikow)
│       └── LogManager.ts               (zarzadzanie logami)
└── assets/                          (zasoby graficzne)
\end{lstlisting}
\section{Implementacja szyfru Cezara}
\subsection{Podstawy}
Szyfr Cezara to prosty szyfr monoalfabetyczny, w którym litery przesuwane są o wartość klucza $k$. 
Przestrzeń kluczy obejmuje wartości $1$-$25$. 
Metoda jest podatna na ataki brute-force i analizę częstotliwości.

\subsection{Model matematyczny}
\begin{itemize}
    \item Szyfrowanie: $E_k(x) = (x + k) \bmod 26$,
    \item Deszyfrowanie: $D_k(x) = (x - k) \bmod 26$.
\end{itemize}

\subsection{Cechy implementacji}
\begin{itemize}
    \item Obsługuje zarówno wielkie jak i małe litery,
    \item Znaki niebędące literami pozostają bez zmian,
    \item Klucz musi być liczbą całkowitą z zakresu 1-25,
    \item Walidacja klucza zwraca szczegółową informację o błędach.
\end{itemize}

\newpage
\section{Implementacja szyfru Vigenère'a}

\subsection{Historia i znaczenie}
Szyfr Vigenère'a został opracowany w XVI wieku przez Blaise de Vigenère'a. 
Przez długi czas uważany był za niezniszczalny (\textit{le chiffre indéchiffrable}) 
aż do jego przełamania przez Charles'a Babbage'a w XIX wieku.

\subsection{Podstawy}
Szyfr Vigenère'a to szyfr \textbf{polialfabetyczny}, który wykorzystuje słowo-klucz 
do generowania serii przesunięć. W przeciwieństwie do szyfru Cezara, 
każda litera tekstu może być szyfrowana z innym przesunięciem.

\subsection{Model matematyczny}
\begin{itemize}
    \item Szyfrowanie: $E_{k}(x_i) = (x_i + k_{i \bmod |k|}) \bmod 26$,
    \item Deszyfrowanie: $D_{k}(y_i) = (y_i - k_{i \bmod |k|}) \bmod 26$,
    \item gdzie $k$ to słowo-klucz, a $|k|$ to jego długość.
\end{itemize}

\subsection{Przykład działania}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Tekst jawny & A & T & T & A & C & K \\
\hline
Klucz & L & E & M & O & N & L \\
\hline
Przesunięcia & +11 & +4 & +12 & +14 & +13 & +11 \\
\hline
Tekst zaszyfrowany & L & X & F & O & P & V \\
\hline
\end{tabular}
\end{center}

\subsection{Cechy implementacji}
\begin{itemize}
    \item Klucz może zawierać tylko litery (A-Z, a-z),
    \item Klucz nie może być pusty,
    \item Znaki niebędące literami w tekście źródłowym są przepisywane bez zmian,
    \item Klucz automatycznie się powtarza dla długich tekstów,
    \item Obsługuje zarówno wielkie jak i małe litery w tekście.
\end{itemize}
\newpage
\section{Implementacja szyfru z kluczem bieżącym}

Szyfr z kluczem bieżącym (Running Key Cipher) to polialfabetyczny szyfr substytucyjny będący rozwinięciem szyfru Vigenère'a. Główna różnica polega na tym, że klucz ma długość co najmniej równą długości szyfrowanej wiadomości, co znacząco zwiększa bezpieczeństwo.

\subsection{Historia i koncepcja}
Szyfr z kluczem bieżącym był używany już w XIX wieku. Klasycznie jako klucza używano fragmentów książek, gazet lub innych długich tekstów. Idea polega na tym, że klucz nie powtarza się (lub powtarza bardzo rzadko), co eliminuje główną słabość szyfru Vigenère'a - podatność na analizę Kasiskiego.

Gdy klucz jest:
\begin{itemize}
    \item \textbf{tekstem z książki} - szyfr jest podatny na kryptoanalizę (klucz ma strukturę języka naturalnego),
    \item \textbf{losowy i używany jednorazowo} - otrzymujemy \textbf{One-Time Pad} (teoretycznie nie do złamania).
\end{itemize}

\subsection{Algorytm szyfrowania i deszyfrowania}
Model matematyczny jest identyczny jak w szyfrze Vigenère'a, ale klucz ma długość $|k| \geq |x|$:

\textbf{Szyfrowanie:}
\begin{itemize}
    \item $E_{k}(x_i) = (x_i + k_i) \bmod 26$
    \item gdzie $x_i$ - $i$-ty znak tekstu jawnego (0-25),
    \item $k_i$ - $i$-ty znak klucza (0-25),
    \item wynik - zaszyfrowany znak.
\end{itemize}

\textbf{Deszyfrowanie:}
\begin{itemize}
    \item $D_{k}(c_i) = (c_i - k_i + 26) \bmod 26$
    \item gdzie $c_i$ - $i$-ty znak szyfrogramu.
\end{itemize}

\subsection{Przykład działania}
Załóżmy, że chcemy zaszyfrować słowo \texttt{ATTACK} używając klucza \texttt{LOREMIPSUM} (fragmentu tekstu Lorem Ipsum):

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Tekst jawny & A & T & T & A & C & K \\
\hline
Pozycja & 0 & 19 & 19 & 0 & 2 & 10 \\
\hline
Klucz & L & O & R & E & M & I \\
\hline
Pozycja klucza & 11 & 14 & 17 & 4 & 12 & 8 \\
\hline
Suma (mod 26) & 11 & 7 & 10 & 4 & 14 & 18 \\
\hline
Tekst zaszyfrowany & L & H & K & E & O & S \\
\hline
\end{tabular}
\end{center}

Wynik: \texttt{ATTACK} $\rightarrow$ \texttt{LHKEOS}

\subsection{Bezpieczeństwo}
\textbf{Zalety:}
\begin{itemize}
    \item Eliminuje periodyczność klucza - ataki typu Kasiskiego są nieskuteczne,
    \item Przy losowym kluczu jednorazowym - teoretycznie bezpieczny (doskonała tajemnica),
    \item Długi klucz znacząco utrudnia kryptoanalizę statystyczną.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item Wymaga bardzo długich kluczy (minimum długość tekstu),
    \item Klucz musi być przekazany bezpiecznym kanałem,
    \item Przy użyciu tekstu naturalnego jako klucza - podatny na kryptoanalizę (struktura języka),
    \item Praktycznie niepraktyczny w rzeczywistych zastosowaniach (poza OTP).
\end{itemize}

\textbf{Atak na szyfr:}
Jeśli klucz jest tekstem w języku naturalnym, można zastosować:
\begin{itemize}
    \item Analizę statystyczną struktur języka,
    \item Ataki słownikowe (próbowanie znanych tekstów jako kluczy),
    \item Analizę bigramów i trigramów.
\end{itemize}

\subsection{One-Time Pad (OTP)}
Gdy klucz spełnia warunki:
\begin{enumerate}
    \item Jest \textbf{całkowicie losowy},
    \item Ma długość \textbf{co najmniej równą tekstowi},
    \item Jest używany \textbf{tylko raz},
    \item Jest znany \textbf{tylko nadawcy i odbiorcy},
\end{enumerate}
otrzymujemy One-Time Pad - jedyny szyfr z udowodnioną matematycznie \textbf{doskonałą tajemnicą} (Shannon, 1949).

\subsection{Zastosowania historyczne}
\begin{itemize}
    \item \textbf{Dyplomacja} - szyfrowanie tajnych depesz (XIX-XX wiek),
    \item \textbf{Wojskowość} - komunikacja wojskowa (WWII, Zimna Wojna),
    \item \textbf{Czerwony Telefon} - linia Waszyngton-Moskwa używała OTP,
    \item \textbf{Wywiad} - agenci używali książek jako kluczy.
\end{itemize}

\subsection{Cechy implementacji w CryptoLab}
\begin{itemize}
    \item Klucz może zawierać litery (A-Z, a-z) i spacje,
    \item Minimalna długość klucza: 5 liter (bez liczenia spacji),
    \item Automatyczne generowanie klucza z Lorem Ipsum,
    \item Wynik w formacie: \texttt{<klucz>::<szyfrogram>},
    \item Znaki niebędące literami w tekście źródłowym są przepisywane bez zmian,
    \item Obsługa wielkich i małych liter,
    \item Szczegółowe logowanie każdego kroku procesu.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/Szyfr_z_kb.jpg}
    \caption{Ekran szyfru z kluczem bieżącym w aplikacji CryptoLab}
    \label{fig:running_key}
\end{figure}
Rysunek \ref{fig:running_key} przedstawia interfejs użytkownika szyfru z kluczem bieżącym w aplikacji CryptoLab Mobile. Widoczny jest automatycznie wygenerowany klucz oraz proces szyfrowania wiadomości.
\newpage
\section{Implementacja szyfru AES}

AES (Advanced Encryption Standard, 2001, Daemen/Rijmen) to najpopularniejszy szyfr symetryczny - chroni SSL/TLS, systemy bankowe, dyski. Następca DES, obecnie globalny standard bezpieczeństwa.

\subsection{Podstawy}
AES to szyfr \textbf{blokowy}, który operuje na blokach danych o długości 128 bitów (16 bajtów). 
W przeciwieństwie do szyfrów klasycznych, AES wykorzystuje skomplikowane operacje matematyczne na macierzach bajtów, 
w tym podstawienia (S-Box), permutacje, mieszanie kolumn i dodawanie klucza rundowego.

\subsection{Warianty AES}
AES występuje w trzech wariantach, różniących się długością klucza:
\begin{itemize}
    \item \textbf{AES-128} - klucz 128-bitowy (32 znaki hex), 10 rund szyfrowania,
    \item \textbf{AES-192} - klucz 192-bitowy (48 znaków hex), 12 rund szyfrowania,
    \item \textbf{AES-256} - klucz 256-bitowy (64 znaki hex), 14 rund szyfrowania.
\end{itemize}

Im dłuższy klucz, tym wyższe bezpieczeństwo, ale także nieznacznie wolniejsze działanie.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/strona_glownaAES.jpg}
    \caption{Strona główna szyfru AES w aplikacji CryptoLab}
    \label{fig:aes_main}
\end{figure}
Rysunek \ref{fig:aes_main} przedstawia interfejs użytkownika aplikacji CryptoLab Mobile dla szyfru AES.
\subsection{Tryby pracy AES}
Szyfr blokowy wymaga określenia \textbf{trybu pracy}, który definiuje sposób szyfrowania wielu bloków danych:

\begin{description}
    \item[\textbf{ECB (Electronic Codebook)}] 
    Najprostszy tryb - każdy blok szyfrowany jest niezależnie tym samym kluczem. 
    \textbf{Niezalecany} w praktyce, ponieważ identyczne bloki tekstu jawnego dają identyczne bloki szyfrogramu, 
    co może ujawnić wzorce w danych.
    \begin{figure}
        \centering
        \includegraphics[width=0.3\textwidth]{img/ECB.jpg}
        \caption{Tryb ECB w szyfrze AES}
        \label{fig:ecb}
    \end{figure}
    Rysunek \ref{fig:ecb} przedstawia przykładowe szyfrowanie tekstu w trybiie ECB.
    
    \item[\textbf{CBC (Cipher Block Chaining)}] 
    Każdy blok tekstu jawnego jest najpierw XOR-owany z poprzednim blokiem szyfrogramu przed zaszyfrowaniem. 
    Wymaga wektora inicjalizującego (IV). Tryb ten ukrywa wzorce w danych i jest szeroko stosowany.
    \begin{figure}
        \centering
        \includegraphics[width=0.3\textwidth]{img/CBC.jpg}
        \caption{Tryb CBC w szyfrze AES}
        \label{fig:cbc}
    \end{figure}
    Rysunek \ref{fig:cbc} przedstawia przykładowe deszyfrowanie tekstu w trybiie CBC.
    \item[\textbf{CTR (Counter Mode)}] 
    Przekształca szyfr blokowy w szyfr strumieniowy. 
    Szyfruje kolejne wartości licznika, a wyniki XOR-uje z blokami tekstu jawnego. 
    Umożliwia równoległe szyfrowanie i deszyfrowanie.
    \begin{figure}
        \centering
        \includegraphics[width=0.3\textwidth]{img/CTR.jpg}
        \caption{Tryb CTR w szyfrze AES}
        \label{fig:ctr}
    \end{figure}
    Rysunek \ref{fig:ctr} przedstawia przykładowe szyfrowanie tekstu w trybiie CTR.
\end{description}

\newpage
\subsection{Struktura algorytmu AES}
Algorytm AES składa się z następujących kroków (dla każdej rundy):
\begin{enumerate}
    \item \textbf{SubBytes} - podstawienie bajtów zgodnie z tablicą S-Box,
    \item \textbf{ShiftRows} - przesunięcie wierszy macierzy stanu,
    \item \textbf{MixColumns} - mieszanie kolumn macierzy (pomijane w ostatniej rundzie),
    \item \textbf{AddRoundKey} - dodanie klucza rundowego (operacja XOR).
\end{enumerate}

Przed pierwszą rundą wykonywana jest operacja \texttt{AddRoundKey} z kluczem początkowym.

\subsection{Cechy implementacji}
\begin{itemize}
    \item Obsługuje klucze w formacie szesnastkowym (hex),
    \item Klucz musi mieć długość 32, 48 lub 64 znaki hex (AES-128/192/256),
    \item Domyślny klucz: \texttt{2b7e151628aed2a6abf7158809cf4f3c} (AES-128),
    \item Implementuje trzy tryby pracy: ECB, CBC, CTR,
    \item Używa paddingu PKCS\#7 dla dopełnienia bloków,
    \item Generuje losowy wektor inicjalizujący (IV) dla trybów CBC i CTR,
    \item Wynik szyfrowania zwracany w formacie hex,
    \item Pełna implementacja bez użycia zewnętrznych bibliotek kryptograficznych.
\end{itemize}

\subsection{Bezpieczeństwo}
\begin{itemize}
    \item AES jest uważany za \textbf{kryptograficznie bezpieczny} przy prawidłowym użyciu,
    \item Nie znaleziono praktycznych ataków na pełny AES-128, AES-192 ani AES-256,
    \item Teoretyczne ataki istnieją, ale wymagają zasobów przekraczających możliwości obecnej technologii,
    \item Bezpieczeństwo zależy od:
    \begin{itemize}
        \item wyboru odpowiedniego trybu pracy (CBC lub CTR zamiast ECB),
        \item użycia losowego IV dla trybów CBC i CTR,
        \item odpowiedniej długości klucza (zalecane minimum: AES-128),
        \item bezpiecznego przechowywania i dystrybucji klucza.
    \end{itemize}
\end{itemize}

\subsection{Zastosowania}
AES jest wykorzystywany w:
\begin{itemize}
    \item szyfrowanie połączeń internetowych (HTTPS, SSL/TLS),
    \item pełne szyfrowanie dysków (BitLocker, FileVault),
    \item sieci bezprzewodowe (WPA2, WPA3),
    \item aplikacje bankowe i systemy płatności,
    \item komunikatory szyfrowane (Signal, WhatsApp),
    \item archiwizacja danych (7-Zip, WinRAR z szyfrowaniem AES).
\end{itemize}

\newpage
\section{Kryptografia asymetryczna - RSA}

RSA (Rivest-Shamir-Adleman, 1977 MIT) rozwiązał problem bezpiecznej wymiany kluczy. Para kluczy: \textbf{publiczny} (szyfrowanie, można udostępniać) i \textbf{prywatny} (deszyfrowanie, tajny). Bezpieczeństwo: trudność faktoryzacji dużych liczb złożonych ($n = p \cdot q$).

\subsection{Model matematyczny}

\textbf{Generowanie kluczy:}
\begin{enumerate}
    \item Wybierz dwie duże liczby pierwsze: $p$ i $q$
    \item Oblicz moduł: $n = p \cdot q$
    \item Oblicz funkcję Eulera: $\phi(n) = (p-1)(q-1)$
    \item Wybierz wykładnik publiczny $e$, taki że: $1 < e < \phi(n)$ oraz $\gcd(e, \phi(n)) = 1$
    \item Oblicz wykładnik prywatny $d$, taki że: $d \cdot e \equiv 1 \pmod{\phi(n)}$
    \item Klucz publiczny: $(e, n)$
    \item Klucz prywatny: $(d, n)$
\end{enumerate}

\textbf{Szyfrowanie i deszyfrowanie:}
\begin{itemize}
    \item Szyfrowanie (klucz publiczny): $c = m^e \bmod n$
    \item Deszyfrowanie (klucz prywatny): $m = c^d \bmod n$
    \item gdzie $m$ - wiadomość, $c$ - szyfrogram
\end{itemize}

\subsection{Przykład działania}
Niech $p = 61$, $q = 53$:
\begin{align*}
n &= 61 \cdot 53 = 3233 \\
\phi(n) &= 60 \cdot 52 = 3120 \\
e &= 17 \quad (\gcd(17, 3120) = 1) \\
d &= 2753 \quad (17 \cdot 2753 \equiv 1 \pmod{3120})
\end{align*}

\textbf{Klucz publiczny:} $(17, 3233)$ \\
\textbf{Klucz prywatny:} $(2753, 3233)$

Szyfrowanie litery 'A' (kod ASCII: 65):
$$c = 65^{17} \bmod 3233 = 2790$$

Deszyfrowanie:
$$m = 2790^{2753} \bmod 3233 = 65$$

\subsection{Cechy implementacji}
\begin{itemize}
    \item Generowanie par kluczy z losowymi liczbami pierwszymi,
    \item Dla celów edukacyjnych używa małych liczb pierwszych (100-300),
    \item W praktyce RSA wymaga liczb o długości 2048+ bitów,
    \item Implementuje algorytm Euklidesa dla obliczenia NWD,
    \item Rozszerzony algorytm Euklidesa dla odwrotności modularnej,
    \item Szybkie potęgowanie modularne dla efektywnego szyfrowania,
    \item Format kluczy: "wykładnik,moduł" (np. "17,3233"),
    \item Każdy znak tekstu szyfrowany osobno,
    \item Wynik w postaci liczb rozdzielonych spacjami.
\end{itemize}

\subsection{Jak wygenerować klucze RSA}
Aplikacja mobilna posiada wbudowaną funkcję generowania kluczy RSA bezpośrednio w interfejsie użytkownika.

\textbf{Generowanie kluczy w aplikacji (zalecane):}
\begin{enumerate}
    \item Wybierz algorytm RSA z listy
    \item Kliknij przycisk \textbf{"Generuj klucze"} obok pola klucza
    \item Aplikacja wyświetli okno z wygenerowanymi kluczami:
    \begin{itemize}
        \item Klucz publiczny (do szyfrowania)
        \item Klucz prywatny (do deszyfrowania)
    \end{itemize}
    \item Możesz skopiować klucze lub bezpośrednio użyć jednego z nich
    \item Zapisz oba klucze w bezpiecznym miejscu!
\end{enumerate}

\textbf{Opcja 1: Użycie przykładowych kluczy testowych}
\begin{itemize}
    \item Klucz publiczny: \texttt{17,323} (e=17, n=323)
    \item Klucz prywatny: \texttt{233,323} (d=233, n=323)
\end{itemize}

\textbf{Opcja 2: Wygenerowanie własnych kluczy w konsoli przeglądarki}
\begin{lstlisting}[language=JavaScript, caption={Generowanie kluczy RSA w konsoli}]
// Skopiuj kod RSACipher do konsoli, a nastepnie:
const rsa = new RSACipher();
const keys = rsa.generateKeyPair();
console.log('Klucz publiczny:', rsa.formatPublicKey());
console.log('Klucz prywatny:', rsa.formatPrivateKey());
\end{lstlisting}

\textbf{Opcja 3: Obliczenie ręczne (cel edukacyjny)}
\begin{enumerate}
    \item Wybierz dwie małe liczby pierwsze, np. p=17, q=19
    \item Oblicz n = p × q = 323
    \item Oblicz φ(n) = (p-1)(q-1) = 16 × 18 = 288
    \item Wybierz e takie, że NWD(e, 288) = 1, np. e=17
    \item Oblicz d = e$^{-1}$ mod φ(n), np. d=233
    \item Klucz publiczny: (17, 323), klucz prywatny: (233, 323)
\end{enumerate}

\subsection{Bezpieczeństwo}
\begin{itemize}
    \item RSA jest bezpieczny przy użyciu odpowiednio dużych kluczy (2048+ bitów),
    \item Bezpieczeństwo opiera się na trudności faktoryzacji dużych liczb,
    \item Zagrożenia:
    \begin{itemize}
        \item Komputery kwantowe (algorytm Shora może złamać RSA),
        \item Zbyt małe klucze (łatwa faktoryzacja),
        \item Słabe generatory liczb pierwszych,
        \item Ataki czasowe (timing attacks) przy nieodpowiedniej implementacji.
    \end{itemize}
    \item Zalecenia:
    \begin{itemize}
        \item Minimum 2048 bitów dla zastosowań praktycznych,
        \item 3072-4096 bitów dla długoterminowego bezpieczeństwa,
        \item Używanie sprawdzonych bibliotek kryptograficznych w produkcji.
    \end{itemize}
\end{itemize}

\subsection{Zastosowania}
RSA jest wykorzystywany w:
\begin{itemize}
    \item \textbf{Podpisy cyfrowe} - uwierzytelnianie dokumentów i oprogramowania,
    \item \textbf{Wymiana kluczy} - bezpieczne przesyłanie kluczy symetrycznych (SSL/TLS),
    \item \textbf{Certyfikaty SSL/TLS} - zabezpieczenie połączeń HTTPS,
    \item \textbf{SSH} - bezpieczne logowanie do serwerów,
    \item \textbf{PGP/GPG} - szyfrowanie poczty elektronicznej,
    \item \textbf{Blockchain} - weryfikacja transakcji w kryptowalutach.
\end{itemize}

\newpage
\section{Algorytm ElGamal}

\subsection{Historia i znaczenie}
System szyfrowania ElGamal został zaproponowany przez Tahera ElGamala w 1985 roku. 
Jest to asymetryczny algorytm klucza publicznego, którego bezpieczeństwo opiera się na trudności problemu \textbf{logarytmu dyskretnego} w ciałach skończonych. 
Algorytm ten jest rozwinięciem protokołu wymiany kluczy Diffiego-Hellmana.

\subsection{Model matematyczny}
Bezpieczeństwo systemu opiera się na fakcie, że choć łatwo jest obliczyć potęgę $g^x \pmod p$, to bardzo trudno jest obliczyć wykładnik $x$, znając jedynie wynik potęgowania, podstawę i moduł (gdy liczby są odpowiednio duże).

\textbf{Generowanie kluczy:}
\begin{enumerate}
    \item Wybierz dużą liczbę pierwszą $p$.
    \item Znajdź generator $g$ (pierwiastek pierwotny modulo $p$).
    \item Wybierz losowy klucz prywatny $x$, taki że $1 < x < p-1$.
    \item Oblicz klucz publiczny $y = g^x \pmod p$.
    \item Klucz publiczny: $(p, g, y)$, Klucz prywatny: $(x, p)$.
\end{enumerate}

\textbf{Szyfrowanie:}
Aby zaszyfrować wiadomość $m$ dla odbiorcy z kluczem publicznym $(p, g, y)$:
\begin{enumerate}
    \item Wybierz losową liczbę $k$ (klucz efemeryczny), taką że $1 < k < p-1$.
    \item Oblicz $a = g^k \pmod p$.
    \item Oblicz $b = (y^k \cdot m) \pmod p$.
    \item Szyfrogram to para $(a, b)$.
\end{enumerate}
\textbf{Deszyfrowanie:}
Aby odszyfrować parę $(a, b)$ przy użyciu klucza prywatnego $x$:
\begin{enumerate}
    \item Oblicz współczynnik $s = a^x \pmod p$.
    \item Oblicz odwrotność $s^{-1} \pmod p$.
    \item Wiadomość $m = b \cdot s^{-1} \pmod p$.
\end{enumerate}

\subsection{Cechy implementacji}
Implementacja wykorzystuje liczby pierwsze w zakresie 300-1000, szyfruje znaki osobno generując pary $(a, b)$ z losowym kluczem $k$ (niedeterministyczność).

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/elgamal_szyfr.jpg}
    \includegraphics[width=0.3\textwidth]{img/elgamal_deszyfr.jpg}
    \caption{Ekran szyfru i deszyfru ElGamal w aplikacji CryptoLab}
    \label{fig:elgamal}
\end{figure}
Rysunek \ref{fig:elgamal} przedstawia interfejs użytkownika aplikacji CryptoLab Mobile dla szyfru ElGamal.
\newpage
\section{Protokół ECDH i Krzywe Eliptyczne}
\subsection{Wprowadzenie}
ECC zapewnia bezpieczeństwo porównywalne z RSA przy krótszych kluczach (256-bit ECC $\approx$ 3072-bit RSA). Równanie krzywej: $y^2 = x^3 + ax + b \pmod p$.

\subsection{Protokół ECDH}
ECDH służy do uzgodnienia wspólnego sekretu przez niezabezpieczony kanał.

\textbf{Zasada działania:}
\begin{enumerate}
    \item Strony uzgadniają parametry krzywej (punkt bazowy $G$, parametry $a, b, p$).
    \item Alice generuje prywatny klucz $d_A$ i oblicza publiczny $Q_A = d_A \cdot G$.
    \item Bob generuje prywatny klucz $d_B$ i oblicza publiczny $Q_B = d_B \cdot G$.
    \item Strony wymieniają się kluczami publicznymi.
    \item Alice oblicza sekret $S = d_A \cdot Q_B$.
    \item Bob oblicza sekret $S = d_B \cdot Q_A$.
    \item Ponieważ $d_A \cdot (d_B \cdot G) = d_B \cdot (d_A \cdot G)$, obie strony uzyskują ten sam punkt $S$.
\end{enumerate}
\newpage
\subsection{Implementacja ECIES}
Aplikacja implementuje schemat ECIES: nadawca generuje klucz efemeryczny, oblicza wspólny sekret, używa współrzędnej X jako klucza XOR.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/klucze_ecdh.jpg}
    \caption{Wygenerowane klucze ECDH w aplikacji CryptoLab}
    \label{fig:ecdh}
\end{figure}
Rysunek \ref{fig:ecdh} przedstawia wygenerowane klucze ECDH w aplikacji CryptoLab Mobile.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/ecdh_szyfrowanie.jpg}
    \includegraphics[width=0.3\textwidth]{img/ecdh_deszyfr.jpg}
    \caption{Proces szyfrowania i deszyfrowania ECDH w aplikacji CryptoLab}
    \label{fig:ecdh_encrypt}
\end{figure}
Rysunek \ref{fig:ecdh_encrypt} przedstawia proces szyfrowania i deszyfrowania ECDH w aplikacji CryptoLab Mobile.

\section{Funkcja skrótu SHA-256}
\subsection{Wprowadzenie}
Funkcje skrótu są jednokierunkowe i generują skrót stałej długości. Cechy: deterministyczność, efekt lawiny, odporność na kolizje, jednokierunkowość.

SHA-256 (SHA-2, NIST 2001): 256-bitowy skrót, 512-bitowy blok, 64 rundy, operacje bitowe.

\subsection{Algorytm}
\textbf{1. Preprocessing:} bit '1', zera do $\equiv 448 \pmod{512}$, 64-bit długości.

\textbf{2. Inicjalizacja:} Stałe $H_0 = \text{0x6a09e667}, \ldots, H_7 = \text{0x5be0cd19}$.

\textbf{3. Kompresja 64 rund:} Harmonogram $W_0, \ldots, W_{63}$, funkcje $Ch(x,y,z) = (x \land y) \oplus (\neg x \land z)$, $Maj(x,y,z)$, $\Sigma$, $\sigma$.

\textbf{4. Wynik:} Konkatenacja $H_0$ do $H_7$.

\subsection{Zastosowania}
Podpisy cyfrowe, blockchain (Bitcoin), SSL/TLS, sumy kontrolne, HMAC, haszowanie haseł.

\subsection{Bezpieczeństwo}
Brak znanych ataków kolizyjnych. Złożoność brutalna: $2^{256}$, urodzinowy: $2^{128}$.

\subsection{Implementacja}
Pełna implementacja: preprocessing, funkcje $Ch$/$Maj$/$\Sigma$/$\sigma$, 64 rundy, UTF-8, szczegółowe logi. Funkcja jednokierunkowa - brak deszyfrowania.

\section{Podpis Elektroniczny (Digital Signature)}
\subsection{Wprowadzenie}
Podpis cyfrowy zapewnia: autentyczność, integralność, niezaprzeczalność (w odróżnieniu od szyfrowania dającego poufność).


\subsection{Schemat podpisu RSA-SHA256}
Aplikacja CryptoLab implementuje schemat podpisu cyfrowego łączący RSA z SHA-256:

\textbf{Proces podpisywania:}
\begin{enumerate}
    \item Oblicz skrót SHA-256 dokumentu: $h = \text{SHA-256}(dokument)$
    \item Konwertuj skrót na liczbę całkowitą (użyj pierwszych 3 znaków hex dla małego RSA)
    \item Podpisz skrót kluczem prywatnym: $s = h^d \bmod n$
    \item Zwróć: dokument, hash, podpis, klucz publiczny
\end{enumerate}

\textbf{Proces weryfikacji:}
\begin{enumerate}
    \item Odbierz: dokument, hash oryginalny, podpis, klucz publiczny
    \item Oblicz skrót SHA-256 otrzymanego dokumentu: $h' = \text{SHA-256}(dokument)$
    \item Porównaj $h'$ z oryginalnym hashem (sprawdzenie integralności)
    \item Odszyfruj podpis kluczem publicznym: $h'' = s^e \bmod n$
    \item Porównaj $h'$ z $h''$ - jeśli zgodne, podpis jest ważny
\end{enumerate}


\subsection{Format}
$$\text{dokument}|\text{hash}|\text{podpis}|\text{klucz\_publiczny}$$

\subsection{Parametry RSA (edukacyjne)}
$p = 61, q = 53, n = 3233, e = 17, d = 2753$. W produkcji: 2048-4096 bitów.

\subsection{Bezpieczeństwo}
Wymaga: tajnego klucza prywatnego, silnych kluczy, bezpiecznej funkcji skrótu (SHA-256), paddingu (PSS).

\subsection{Zastosowania}
SSL/TLS, podpisywanie oprogramowania, dokumenty elektroniczne (eIDAS), transakcje finansowe, blockchain, e-mail (S/MIME, PGP), aktualizacje systemu.

\subsection{Implementacja}
Pełna implementacja: generowanie kluczy RSA (12-bit edukacyjne), integracja SHA-256, modular exponentiation, rozszerzony algorytm Euklidesa, szczegółowe logi, wykrywanie modyfikacji, walidacja WAŻNY/NIEWAŻNY.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/podpis_podpisywanie.jpg}
        \includegraphics[width=0.3\textwidth]{img/podpis_weryfikacja.jpg}
    \caption{Ekran podpisywania dokumentu w aplikacji CryptoLab i weryfikacja podpisu}
    \label{fig:digital_signature_sign}
\end{figure}
Rysunek \ref{fig:digital_signature_sign} przedstawia proces podpisywania dokumentu - system generuje pełny podpis cyfrowy (dokument|hash|podpis RSA|klucz publiczny).Natomiast rysunek obok, weryfikację podpisu - system sprawdza integralność (SHA-256) i autentyczność (klucz publiczny), wyświetlając PODPIS WAŻNY/NIEWAŻNY.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/logi_podpis.jpg}
    \caption{Szczegółowe logi procesu podpisywania}
    \label{fig:digital_signature_logs}
\end{figure}
Rysunek \ref{fig:digital_signature_logs} pokazuje szczegółowe logi procesu podpisywania: SHA-256, konwersja hasha, podpisywanie kluczem prywatnym.


\newpage
\section{Wybrane fragmenty kodu}
\subsection{Klasa bazowa algorytmu}
\begin{lstlisting}[language=TypeScript, caption={Klasa abstrakcyjna CryptographicAlgorithm}]
export default class CryptographicAlgorithm {
  name: string;
  description: string;
  category: string;

  encrypt(plaintext: string, key: string): string {
    throw new Error('Metoda encrypt() musi być zaimplementowana');
  }

  decrypt(ciphertext: string, key: string): string {
    throw new Error('Metoda decrypt() musi być zaimplementowana');
  }

  validateKey(key: string): { valid: boolean; error?: string } {
    throw new Error('Metoda validateKey() musi być zaimplementowana');
  }

  getKeyRequirements(): string {
    throw new Error('Metoda getKeyRequirements() musi być zaimplementowana');
  }
}
\end{lstlisting}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/szyfr_cezara.jpg}
    \caption{Ekran główny aplikacji CryptoLab}
    \label{fig:main}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/lista_wyboru.jpg}
    \caption{Lista z możliwością wyboru algorytmu}
    \label{fig:list}
\end{figure}

Rysunek \ref{fig:main} przedstawia ekran główny aplikacji CryptoLab Mobile, a rysunek \ref{fig:list} pokazuje listę dostępnych algorytmów kryptograficznych.
\newpage
\subsection{Implementacja szyfru Cezara}
\begin{lstlisting}[language=TypeScript, caption={Fragment CaesarCipher}]
encrypt(plaintext: string, key: string): string {
  return text.split('').map(char => {
    if (/[A-Za-z]/.test(char)) {
      const base = char === char.toUpperCase() ? 65 : 97;
      return String.fromCharCode(
          (char.charCodeAt(0) - base + shift) % 26 + base
        );
      }
      return char;
    }).join('');
  }
}
\end{lstlisting}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/test_cezara.jpg}
    \caption{Test szyfru Cezara}
    \label{fig:testc}
\end{figure}
Rysunek \ref{fig:testc} przedstawia przykładowy test szyfru Cezara w aplikacji CryptoLab Mobile.

\newpage
\subsection{Implementacja szyfru Vigenère'a}
\begin{lstlisting}[language=TypeScript, caption={Kluczowy fragment VigenereCipher}]
private _process(text: string, key: string, encrypt: boolean): string {
  let result = '';
  let keyIndex = 0;
  const normalizedKey = key.toUpperCase();
  
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    if (/[A-Za-z]/.test(char)) {
      const base = char === char.toUpperCase() ? 65 : 97;
      const textCode = char.charCodeAt(0) - base;
      // Klucz powtarza się cyklicznie
      const keyCode = normalizedKey.charCodeAt(keyIndex % normalizedKey.length) - 65;
      
      // Operacja kryptograficzna Vigenere
      const resultCode = encrypt 
        ? (textCode + keyCode) % 26 
        : (textCode - keyCode + 26) % 26;
      
      result += String.fromCharCode(resultCode + base);
      keyIndex++;
    } else {
      result += char;
    }
  }
  return result;
}
\end{lstlisting}

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/szyfr_vigenerea.jpg}
    \caption{Ekran szyfru Vigenere'a}
    \label{fig:szyfrv}
\end{figure}
Rysunek \ref{fig:szyfrv} przedstawia interfejs użytkownika szyfru Vigenère'a w aplikacji CryptoLab Mobile.
\subsection{Implementacja szyfru z kluczem bieżącym}
\begin{lstlisting}[language=TypeScript, caption={Fragmenty klasy RunningKeyCipher}]
export default class RunningKeyCipher extends CryptographicAlgorithm {
  constructor() {
    super(
      'Szyfr z kluczem bieżącym',
      'Szyfr podobny do Vigenère\'a, ale używający klucza o długości tekstu',
      'Szyfry klasyczne'
    );
  }

  validateKey(key: string): { valid: boolean; error?: string } {
    if (!key || key.trim().length === 0) {
      return { valid: false, error: 'Klucz nie może być pusty' };
    }
    
    // Sprawdź czy klucz zawiera tylko litery
    const hasOnlyLetters = /^[a-zA-Z\s]+$/.test(key);
    if (!hasOnlyLetters) {
      return { valid: false, error: 'Klucz może zawierać tylko litery i spacje (A-Z, a-z)' };
    }
    
    // Policz tylko litery w kluczu
    const keyLettersCount = key.replace(/[^a-zA-Z]/g, '').length;
    if (keyLettersCount < 5) {
      return { 
        valid: false, 
        error: 'Klucz musi zawierać co najmniej 5 liter (może zawierać spacje)' 
      };
    }
    
    return { valid: true };
  }

  getKeyRequirements(): string {
    return 'Tekst (np. fragment książki) - użyto generatora lorem ipsum do stworzenia klucza';
  }
\end{lstlisting}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/Szyfr_z_kb.jpg}
    \caption{Ekran szyfru z kluczem bieżącym}
    \label{fig:szyfrk}
\end{figure}

Rysunek \ref{fig:szyfrk} przedstawia interfejs użytkownika szyfru z kluczem bieżącym w aplikacji CryptoLab Mobile.

\newpage
\subsection{Implementacja szyfru AES}
\begin{lstlisting}[language=TypeScript, caption={Kluczowe metody AESCipher}]
// Szyfrowanie w zależności od trybu (ECB/CBC/CTR)
encrypt(plaintext: string, key: string): string {
  if (this.mode === 'ECB') return this.encryptECB(plaintext, key);
  if (this.mode === 'CBC') return this.encryptCBC(plaintext, key);
  if (this.mode === 'CTR') return this.encryptCTR(plaintext, key);
}

// ECB - każdy blok niezależnie (NIEZALECANY!)
private encryptECB(plaintext: string, key: string): string {
  const blocks = this.textToBlocks(plaintext);
  return blocks.map(block => this.encryptBlock(block, key))
              .join('');
}

// CBC - z wektorem IV, XOR z poprzednim blokiem
private encryptCBC(plaintext: string, key: string): string {
  const iv = this.generateIV();
  let previousBlock = iv;
  // XOR każdego bloku z poprzednim szyfrogramem
  // ...
}
\end{lstlisting}

\subsection{Implementacja szyfru RSA}
\begin{lstlisting}[language=TypeScript, caption={Kluczowe operacje RSA}]
// Generowanie kluczy
generateKeyPair(): RSAKeyPair {
  const p = generatePrime(100, 300);
  const q = generatePrime(100, 300);
  const n = p * q;                    // Moduł
  const phi = (p - 1) * (q - 1);      // Funkcja Eulera
  const e = 65537;                    // Wykładnik publiczny
  const d = modInverse(e, phi);       // Wykładnik prywatny
  
  return {
    publicKey: { e, n },
    privateKey: { d, n }
  };
}

// Szyfrowanie: c = m^e mod n
encrypt(plaintext: string, key: string): string {
  const [e, n] = key.split(',').map(p => parseInt(p, 10));
  const encrypted = [];
  
  for (const char of plaintext) {
    const m = char.charCodeAt(0);
    const c = modPow(BigInt(m), BigInt(e), BigInt(n));
    encrypted.push(Number(c));
  }
  return encrypted.join(' ');
}

// Deszyfrowanie: m = c^d mod n
decrypt(ciphertext: string, key: string): string {
  const [d, n] = key.split(',').map(p => parseInt(p, 10));
  const numbers = ciphertext.split(' ').map(s => parseInt(s));
  
  return numbers.map(c => {
    const m = modPow(BigInt(c), BigInt(d), BigInt(n));
    return String.fromCharCode(Number(m));
  }).join('');
}
\end{lstlisting}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/RSA.jpg}
    \includegraphics[width=0.3\textwidth]{img/RSA_keygen.jpg}
    \caption{Ekran szyfru RSA oraz generowanie kluczy}
    \label{fig:szyfrrsa}
\end{figure}
Rysunek \ref{fig:szyfrrsa} przedstawia interfejs użytkownika szyfru RSA oraz generowania kluczy w aplikacji CryptoLab Mobile.

\newpage
\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/RSA_szyfrowanie.jpg}
        \includegraphics[width=0.3\textwidth]{img/RSA_deszyfr.jpg}
    \caption{Test szyfru RSA i jego deszyfrowanie}
    \label{fig:testrsa}
\end{figure}
Rysunek \ref{fig:testrsa} przedstawia przykładowy test szyfru RSA oraz jego deszyfrowanie w aplikacji CryptoLab Mobile.

\newpage
\subsection{Implementacja algorytmu ElGamal}
\begin{lstlisting}[language=TypeScript, caption={Kluczowe operacje ElGamal}]
// Generowanie kluczy
generateKeyPair(): ElGamalKeyPair {
  const p = generatePrime(300, 1000);     // Liczba pierwsza
  const g = findPrimitiveRoot(p);         // Generator
  const x = random(2, p-2);               // Klucz prywatny
  const y = modPow(g, x, p);              // Klucz publiczny: y = g^x mod p
  
  return { publicKey: {p, g, y}, privateKey: {x, p} };
}

// Szyfrowanie: (a, b) = (g^k mod p, y^k * m mod p)
encrypt(plaintext: string, key: string): string {
  const [p, g, y] = key.split(',').map(BigInt);
  const encrypted = [];
  
  for (const char of plaintext) {
    const m = BigInt(char.charCodeAt(0));
    const k = random(1, p-2);           // Losowy klucz efemeryczny
    const a = modPow(g, k, p);          // a = g^k mod p
    const b = (modPow(y, k, p) * m) % p;// b = (y^k * m) mod p
    encrypted.push(`${a}:${b}`);
  }
  return encrypted.join(' ');
}
\end{lstlisting}
\newpage
\subsection{Implementacja algorytmu ECDH}
\begin{lstlisting}[language=TypeScript, caption={Kluczowe operacje ECDH}]
// Dodawanie punktów na krzywej: y^2 = x^3 + ax + b (mod p)
private addPoints(P: Point, Q: Point): Point {
  if (P.isInfinity) return Q;
  if (Q.isInfinity) return P;
  
  // Współczynnik nachylenia prostej
  const m = (P === Q) 
    ? (3n * P.x * P.x + CURVE.a) / (2n * P.y)  // Podwójenie
    : (Q.y - P.y) / (Q.x - P.x);               // Dodawanie
  
  const x3 = (m * m - P.x - Q.x) % CURVE.p;
  const y3 = (m * (P.x - x3) - P.y) % CURVE.p;
  return { x: x3, y: y3 };
}

// Szyfrowanie ECIES
encrypt(plaintext: string, key: string): string {
  const Q = parsePoint(key);              // Klucz publiczny odbiorcy
  const k = random(1, CURVE.p-1);         // Losowy klucz efemeryczny
  const R = k * CURVE.G;                  // Punkt efemeryczny: R = k*G
  const S = k * Q;                        // Wspólny sekret: S = k*Q
  const symmetricKey = S.x;               // Klucz XOR
  const ciphertext = XOR(plaintext, symmetricKey);
  return `${R.x},${R.y}|${ciphertext}`;   // (R, szyfrogram)
}
\end{lstlisting}
\newpage
\subsection{Implementacja funkcji SHA-256}
\begin{lstlisting}[language=TypeScript, caption={Kluczowe operacje SHA-256}]
// Stałe i wartości początkowe
private K: number[] = [0x428a2f98, /* ...63 wartości... */, 0xc67178f2];
private H: number[] = [0x6a09e667, 0xbb67ae85, /* ...6 wartości... */];

encrypt(plaintext: string): string {
  const bytes = stringToBytes(plaintext);
  return bytesToHex(this.sha256(bytes));
}

// Główny algorytm - 64 rundy kompresji
private sha256(message: number[]): number[] {
  const blocks = this.preprocess(message);  // Padding do 512-bit
  let H = [...this.H];                      // Kopia wartości początkowych
  
  for (const block of blocks) {
    const W = this.prepareSchedule(block);  // Harmonogram 64 słów
    let [a, b, c, d, e, f, g, h] = H;
    
    // 64 rundy
    for (let t = 0; t < 64; t++) {
      const T1 = h + Sigma1(e) + Ch(e,f,g) + this.K[t] + W[t];
      const T2 = Sigma0(a) + Maj(a,b,c);
      [a,b,c,d,e,f,g,h] = [T1+T2, a, b, c, d+T1, e, f, g];
    }
    
    // Dodaj do H
    H = H.map((v, i) => (v + [a,b,c,d,e,f,g,h][i]) >>> 0);
  }
  return H;
}

// Funkcje logiczne
Ch(x,y,z) { return (x & y) ^ (~x & z); }
Maj(x,y,z) { return (x & y) ^ (x & z) ^ (y & z); }
Sigma0(x) { return ROTR(x,2) ^ ROTR(x,13) ^ ROTR(x,22); }
Sigma1(x) { return ROTR(x,6) ^ ROTR(x,11) ^ ROTR(x,25); }
\end{lstlisting}

\newpage
\subsection{Implementacja podpisu elektronicznego}
\begin{lstlisting}[language=TypeScript, caption={Kluczowe operacje DigitalSignature}]
// Parametry RSA (edukacyjne): p=61, q=53, n=3233, e=17
private P = 61n, Q = 53n, N = 3233n, E = 17n;
private D = modularInverse(this.E, (P-1n)*(Q-1n)); // d=2753

// Podpisywanie: sign(doc) = (doc | hash | hash^d mod n | public_key)
encrypt(document: string): string {
  const hash = SHA256(document);              // 1. Hash dokumentu
  const hashNum = hashToNumber(hash);         // 2. Hash -> liczba (3 hex)
  const signature = modPow(hashNum, D, N);    // 3. Podpis: hash^d mod n
  return `${document}|${hash}|${signature.toString(16)}|${N},${E}`;
}

// Weryfikacja: verify(signed_doc)
decrypt(signedDoc: string): string {
  const [doc, origHash, sigHex, pubKey] = signedDoc.split('|');
  const [n, e] = pubKey.split(',').map(BigInt);
  
  // 1. Sprawd\u017a integralno\u015b\u0107
  const currentHash = SHA256(doc);
  if (currentHash !== origHash) 
    return 'PODPIS NIEWA\u017bNY - Dokument zmieniony!';
  
  // 2. Sprawd\u017a autentyczno\u015b\u0107
  const hashNum = hashToNumber(currentHash);
  const signature = BigInt('0x' + sigHex);
  const verifiedHash = modPow(signature, e, n); // signature^e mod n
  
  return (hashNum === verifiedHash) 
    ? 'PODPIS WA\u017bNY - Dokument autentyczny!'
    : 'PODPIS NIEWA\u017bNY - Podpis fa\u0142szywy!';
}
\end{lstlisting}

\newpage
\section{Podsumowanie}

\subsection{Szyfr Cezara}
Szyfr Cezara należy do najstarszych i najprostszych technik szyfrowania. 
Jego główna idea polega na przesuwaniu liter alfabetu o ustaloną liczbę pozycji. 
Mimo że w praktyce jest to jedynie przykład historyczny, implementacja szyfru pozwala lepiej zrozumieć podstawowe mechanizmy kryptografii, takie jak klucz, szyfrowanie i deszyfrowanie.

\textbf{Zalety:}
\begin{itemize}
    \item bardzo prosta implementacja,
    \item szybkie działanie,
    \item dobre ćwiczenie dydaktyczne.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item niska odporność na ataki kryptograficzne,
    \item atak brute-force łatwe przełamuje szyfr w sekundach,
    \item podatny na analizę częstotliwości.
\end{itemize}

\subsection{Szyfr Vigenère'a}
Szyfr Vigenère'a to znacznie bardziej zaawansowany szyfr polialfabetyczny. 
Przez wieki uważany był za niezniszczalny, 
ale ostatecznie został przełamany dzięki analizie częstotliwości długości okresu.

\textbf{Zalety:}
\begin{itemize}
    \item znacznie bardziej bezpieczny niż szyfr Cezara,
    \item odporne na prostą analizę częstotliwości,
    \item wykorzystuje koncepcję słowa-klucza, co jest intuicyjne.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item niska odporność na ataki kryptograficzne (możliwy atak siłowy poprzez sprawdzenie wszystkich przesunięć),
    \item brak zastosowania we współczesnych systemach bezpieczeństwa,
    \item szyfr działa jedynie na ograniczonym zbiorze znaków (najczęściej alfabet łaciński).
\end{itemize}

\newpage
\subsection{Szyfr z kluczem bieżącym}
Szyfr z kluczem bieżącym to krok w kierunku szyfrowania jednorazowego.

\textbf{Zalety:}
\begin{itemize}
    \item gdy klucz jest losowy i używany raz - teoretycznie nie do złamania,
    \item koncepcja zbliża się do rzeczywistego bezpieczeństwa informacyjnego,
    \item edukacyjnie pokazuje znaczenie losowości klucza.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item wymaga przechowywania bardzo długich kluczy,
    \item wymaga absolutnej losowości i jednorazowego użycia,
    \item niepraktyczne w większości rzeczywistych zastosowań.
\end{itemize}

\subsection{Szyfr AES}
AES (Advanced Encryption Standard) to nowoczesny szyfr symetryczny, który stanowi podstawę współczesnej kryptografii. 
W przeciwieństwie do szyfrów klasycznych, AES jest używany w realnych systemach bezpieczeństwa na całym świecie.

\textbf{Zalety:}
\begin{itemize}
    \item wysoki poziom bezpieczeństwa - odporny na wszystkie znane praktyczne ataki,
    \item elastyczność - obsługa trzech długości kluczy (128, 192, 256 bitów),
    \item różne tryby pracy (ECB, CBC, CTR) dostosowane do różnych zastosowań,
    \item szybkie działanie przy zachowaniu bezpieczeństwa,
    \item szeroko stosowany i przetestowany w praktyce,
    \item standaryzowany przez NIST i akceptowany globalnie.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item znacznie bardziej złożona implementacja niż szyfry klasyczne,
    \item wymaga zrozumienia trybów pracy i ich właściwości,
    \item tryb ECB jest niebezpieczny i nie powinien być stosowany w praktyce,
    \item wymaga bezpiecznego zarządzania kluczami i wektorami inicjalizującymi (IV),
    \item jako szyfr symetryczny, wymaga bezpiecznego przekazania klucza obu stronom komunikacji.
\end{itemize}

\textbf{Zastosowanie edukacyjne:}
\begin{itemize}
    \item pokazuje różnicę między kryptografią klasyczną a nowoczesną,
    \item wprowadza pojęcia: tryby pracy, padding, wektor inicjalizujący (IV),
    \item demonstruje znaczenie wyboru odpowiedniego trybu pracy,
    \item ilustruje jak działa rzeczywiste szyfrowanie stosowane w praktyce.
\end{itemize}

\subsection{Szyfr RSA}
RSA to przełomowy algorytm kryptografii asymetrycznej, który rozwiązał fundamentalny problem 
bezpiecznej wymiany kluczy i wprowadził koncepcję kluczy publicznych.

\textbf{Zalety:}
\begin{itemize}
    \item rozwiązuje problem wymiany kluczy - nie wymaga bezpiecznego kanału,
    \item umożliwia podpisy cyfrowe i uwierzytelnianie,
    \item bezpieczny przy odpowiednio dużych kluczach (2048+ bitów),
    \item szeroko stosowany i przetestowany w praktyce,
    \item fundamentalna technologia dla PKI (Public Key Infrastructure),
    \item umożliwia szyfrowanie hybrydowe w połączeniu z AES.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item znacznie wolniejszy niż algorytmy symetryczne (100-1000x),
    \item wymaga dużych kluczy (2048-4096 bitów) dla bezpieczeństwa,
    \item zagrożenie ze strony komputerów kwantowych,
    \item złożona implementacja - łatwo popełnić błędy bezpieczeństwa,
    \item nie nadaje się do szyfrowania dużych ilości danych.
\end{itemize}

\textbf{Zastosowanie edukacyjne:}
\begin{itemize}
    \item wprowadza fundamentalną różnicę między kryptografią symetryczną i asymetryczną,
    \item pokazuje matematyczne podstawy bezpieczeństwa (teoria liczb),
    \item ilustruje koncepcję klucza publicznego i prywatnego,
    \item demonstruje praktyczne zastosowania: wymiana kluczy, podpisy cyfrowe,
    \item pozwala zrozumieć jak działa HTTPS, SSH i inne protokoły bezpieczeństwa.
\end{itemize}

\textbf{RSA w praktyce:}
W rzeczywistych systemach RSA rzadko jest używany do bezpośredniego szyfrowania danych. 
Zamiast tego stosuje się \textbf{szyfrowanie hybrydowe}:
\begin{enumerate}
    \item Generowany jest losowy klucz AES (symetryczny),
    \item Dane szyfrowane są szybkim algorytmem AES,
    \item Klucz AES szyfrowany jest wolnym, ale bezpiecznym RSA,
    \item Przesyłany jest zaszyfrowany klucz AES + zaszyfrowane dane.
\end{enumerate}

To połączenie zapewnia zarówno bezpieczeństwo RSA, jak i szybkość AES.

\subsection{Algorytm ElGamal}
ElGamal to alternatywa dla RSA, oparta na innym problemie matematycznym (logarytm dyskretny).

\textbf{Zalety:}
\begin{itemize}
    \item bezpieczeństwo oparte na dobrze zbadanym problemie matematycznym,
    \item niedeterministyczność szyfrowania (ten sam tekst szyfrowany jest inaczej za każdym razem), co utrudnia kryptoanalizę.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item szyfrogram jest dwukrotnie dłuższy od wiadomości jawnej (para liczb dla każdego bloku),
    \item wolniejsze działanie niż RSA (więcej potęgowań).
\end{itemize}

\subsection{Protokół ECDH}
Kryptografia krzywych eliptycznych (ECC) to przyszłość bezpiecznej komunikacji.

\textbf{Zalety:}
\begin{itemize}
    \item bardzo wysoki poziom bezpieczeństwa przy krótkich kluczach (256-bit ECC $\approx$ 3072-bit RSA),
    \item szybsze obliczenia i mniejsze zużycie energii (ważne w urządzeniach mobilnych),
    \item mniejsze wymagania pamięciowe.
\end{itemize}

\textbf{Wady:}
\begin{itemize}
    \item skomplikowana matematyka i trudniejsza implementacja,
    \item wrażliwość na słabe generatory liczb losowych.
\end{itemize}

\subsection{Funkcja SHA-256}
SHA-256 jest kryptograficzną funkcją skrótu o fundamentalnym znaczeniu dla bezpieczeństwa.

\textbf{Zalety:}
\begin{itemize}
    \item \textbf{jednokierunkowość} - niemożliwe odtworzenie oryginalnej wiadomości,
    \item \textbf{deterministyczność} - ten sam wejście zawsze daje ten sam wynik,
    \item \textbf{efekt lawiny} - minimalna zmiana wejścia drastycznie zmienia skrót,
    \item \textbf{odporność na kolizje} - praktycznie niemożliwe znalezienie dwóch wiadomości o tym samym skrócie,
    \item \textbf{szybkość} - wydajne obliczenia na nowoczesnym sprzęcie,
    \item \textbf{wszechstronność} - używana w blockchain, podpisach cyfrowych, TLS, weryfikacji integralności.
\end{itemize}

\textbf{Wady i ograniczenia:}
\begin{itemize}
    \item nie nadaje się do haszowania haseł bez dodatkowych mechanizmów (salt, iteracje),
    \item brak mechanizmu weryfikacji autentyczności (do tego służy HMAC),
    \item teoretycznie podatna na ataki kwantowe (w odległej przyszłości).
\end{itemize}

\textbf{Zastosowania w praktyce:}
\begin{itemize}
    \item \textbf{Bitcoin i blockchain} - proof-of-work, identyfikacja bloków i transakcji,
    \item \textbf{Podpisy cyfrowe} - haszowanie dokumentów przed podpisaniem,
    \item \textbf{Certyfikaty SSL/TLS} - weryfikacja integralności i autentyczności,
    \item \textbf{Git} - identyfikacja commitów i obiektów (choć Git używa SHA-1),
    \item \textbf{Sumy kontrolne} - weryfikacja pobranych plików.
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/sha-256.jpg}
    \caption{Ekran funkcji SHA-256}
    \label{fig:sha256}
\end{figure}
Rysunek \ref{fig:sha256} przedstawia interfejs użytkownika funkcji SHA-256 w aplikacji CryptoLab Mobile.

\subsection{Podpis Elektroniczny}
Podpis elektroniczny to kryptograficzny mechanizm łączący SHA-256 z RSA do autentykacji dokumentów.

\textbf{Zalety:}
\begin{itemize}
    \item \textbf{Autentyczność} - potwierdza tożsamość nadawcy (tylko właściciel klucza prywatnego może podpisać),
    \item \textbf{Integralność} - wykrywa każdą modyfikację dokumentu,
    \item \textbf{Niezaprzeczalność} - nadawca nie może zaprzeczyć podpisaniu (non-repudiation),
    \item \textbf{Efektywność} - podpisywany jest tylko hash (256 bitów), nie cały dokument,
    \item \textbf{Uniwersalność} - działa dla dokumentów dowolnej wielkości,
    \item \textbf{Zgodność ze standardami} - RSA-SHA256 to powszechnie uznany standard (PKCS\#1).
\end{itemize}

\textbf{Wady i ograniczenia:}
\begin{itemize}
    \item \textbf{Zarządzanie kluczami} - wymaga bezpiecznego przechowywania klucza prywatnego,
    \item \textbf{Infrastruktura PKI} - w praktyce potrzebne są certyfikaty i zaufane centra certyfikacji,
    \item \textbf{Podatność kwantowa} - RSA może być złamany przez komputery kwantowe (w przyszłości),
    \item \textbf{Rozmiar klucza} - duże klucze (2048-4096 bitów) wymagają więcej pamięci.
\end{itemize}

\textbf{Proces w CryptoLab:}
\begin{enumerate}
    \item \textbf{Podpisywanie:} Użytkownik wpisuje dokument → System oblicza SHA-256 → Podpisuje kluczem prywatnym → Zwraca: dokument|hash|podpis|klucz\_publiczny
    \item \textbf{Weryfikacja:} Użytkownik wkleja podpis → System oblicza hash dokumentu → Sprawdza integralność → Weryfikuje podpis kluczem publicznym → Wyświetla: ✅ WAŻNY lub ❌ NIEWAŻNY
\end{enumerate}

\textbf{Zastosowania praktyczne:}
\begin{itemize}
    \item \textbf{SSL/TLS} - certyfikaty serwerów WWW,
    \item \textbf{Podpisy kwalifikowane} - prawnie wiążące dokumenty (eIDAS),
    \item \textbf{Kod aplikacji} - weryfikacja pochodzenia oprogramowania,
    \item \textbf{Blockchain} - autoryzacja transakcji Bitcoin, Ethereum,
    \item \textbf{E-mail} - S/MIME, PGP dla bezpiecznej poczty,
    \item \textbf{Aktualizacje systemu} - weryfikacja integralności pakietów apt, yum.
\end{itemize}

\textbf{Edukacyjne aspekty implementacji:}
\begin{itemize}
    \item Demonstracja związku między SHA-256 a RSA,
    \item Zrozumienie różnicy między szyfrowaniem a podpisywaniem,
    \item Wizualizacja procesu weryfikacji integralności,
    \item Obserwacja efektu modyfikacji dokumentu (podpis staje się nieważny),
    \item Praktyczne zastosowanie modular exponentiation i Extended Euclidean Algorithm.
\end{itemize}

\section{System logowania operacji}
\label{sec:logging}

Aplikacja CryptoLab Mobile zawiera zaawansowany system logowania, 
który rejestruje wszystkie operacje kryptograficzne wykonywane przez użytkownika. 
System ten służy celom edukacyjnym i analitycznym, 
umożliwiając śledzenie historii operacji oraz analizę kroków algorytmów.

\subsection{Architektura systemu logowania}

System logowania składa się z trzech głównych komponentów:

\begin{description}
    \item[\textbf{LogManager.ts}] 
    Singleton zarządzający całym systemem logowania. 
    Odpowiada za:
    \begin{itemize}
        \item rozpoczynanie i kończenie operacji kryptograficznych,
        \item rejestrowanie kroków pośrednich w algorytmach,
        \item zapisywanie logów w pamięci trwałej (AsyncStorage),
        \item powiadamianie komponentów UI o zmianach w logach,
        \item zarządzanie liczbą przechowywanych logów (maksymalnie 100).
    \end{itemize}

    \item[\textbf{LogTypes.ts}] 
    Definicje typów TypeScript dla systemu logowania:
    \begin{itemize}
        \item \texttt{LogStep} - pojedynczy krok w algorytmie,
        \item \texttt{CryptoLogEntry} - kompletny wpis logu operacji,
        \item \texttt{LogFilter} - filtry wyszukiwania logów,
        \item \texttt{LogStats} - statystyki użycia algorytmów.
    \end{itemize}

    \item[\textbf{LogsViewer.tsx}] 
    Komponent React Native wyświetlający historię operacji. 
    Funkcjonalności:
    \begin{itemize}
        \item wyświetlanie listy wszystkich operacji z timestampami,
        \item filtrowanie logów (wszystkie/szyfrowanie/deszyfrowanie),
        \item podgląd szczegółów operacji krok po kroku,
        \item eksport wyników do schowka,
        \item usuwanie pojedynczych logów lub czyszczenie całej historii,
        \item wyświetlanie statystyk (liczba operacji, najczęściej używany algorytm).
    \end{itemize}
\end{description}

\subsection{Rejestrowane informacje}

Każdy wpis logu (\texttt{CryptoLogEntry}) zawiera:

\begin{itemize}
    \item \textbf{Metadane:} ID, timestamp, nazwa algorytmu, typ operacji (encrypt/decrypt)
    \item \textbf{Dane operacji:} tekst wejściowy, tekst wyjściowy, klucz (maskowany dla bezpieczeństwa)
    \item \textbf{Parametry:} tryb pracy (dla AES), długość klucza
    \item \textbf{Status:} sukces/błąd, komunikat błędu (jeśli wystąpił)
    \item \textbf{Wydajność:} czas wykonania operacji w milisekundach
    \item \textbf{Kroki algorytmu:} szczegółowy przebieg operacji z danymi pośrednimi
\end{itemize}

\subsection{Kroki algorytmu}

System loguje szczegółowe kroki wykonywania algorytmów (\texttt{LogStep}), co pozwala użytkownikom:
\begin{itemize}
    \item zrozumieć jak działa algorytm krok po kroku,
    \item zobaczyć transformacje danych na każdym etapie,
    \item debugować problemy z szyfrowaniem/deszyfrowaniem,
    \item analizować różnice między algorytmami.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/logs.jpg}
    \caption{Ekran przeglądu logów}
    \label{fig:logs}
\end{figure}
Rysunek \ref{fig:logs} przedstawia ekran przeglądu logów w aplikacji CryptoLab Mobile.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/logs_all.jpg}
    \includegraphics[width=0.3\textwidth]{img/logs_all_end.jpg}
    \caption{Szczegółowe logi dla przykładowej operacji}
    \label{fig:logdetails}
\end{figure}
Rysunek \ref{fig:logdetails} przedstawia szczegółowe logi dla przykładowej operacji szyfrowania w aplikacji CryptoLab Mobile.
\subsection{Bezpieczeństwo kluczy}

System automatycznie maskuje klucze w logach:
\begin{itemize}
    \item Krótkie klucze (do 10 znaków) - wyświetlane w całości
    \item Średnie klucze (11-30 znaków) - maskowane środkowe znaki
    \item Długie klucze (powyżej 30 znaków) - pokazane tylko pierwsze i ostatnie 10 znaków
    \item Klucze RSA - maskowane dla bezpieczeństwa
\end{itemize}

\subsection{Statystyki}

LogManager oblicza i udostępnia statystyki użycia:
\begin{itemize}
    \item łączna liczba operacji szyfrowania i deszyfrowania,
    \item najczęściej używany algorytm,
    \item wskaźnik sukcesu operacji,
    \item średni czas wykonania operacji.
\end{itemize}

\subsection{Zastosowanie edukacyjne}

System logowania ma kluczowe znaczenie edukacyjne:
\begin{itemize}
    \item pozwala studentom zobaczyć jak algorytmy działają \textit{od środka},
    \item umożliwia porównanie kroków różnych algorytmów,
    \item pomaga zrozumieć złożoność obliczeniową,
    \item wspiera analizę błędów i debugowanie,
    \item dostarcza danych do tworzenia raportów i prezentacji.
\end{itemize}


\section{Changelog}
\label{sec:changelog}
\begin{itemize}
    \item \textbf{14.10.2025} Implementacja szyfru Cezara (szyfrowanie, deszyfrowanie, walidacja klucza) oraz podstawowe GUI.
    \item \textbf{20.10.2025} Dodanie szyfru Vigenère'a i szyfru z kluczem bieżącym. \newline Ulepszenie interfejsu użytkownika. \newline 
    Implementacja AlgorithmRegistry z wzorcem Singleton. 
    \newline Ulepszenie walidacji kluczy z szczegółowymi komunikatami o błędach.
    \item \textbf{28.10.2025} Implementacja szyfru AES (Advanced Encryption Standard) z obsługą trzech trybów pracy: ECB, CBC, CTR. \newline
    Wsparcie dla kluczy AES-128, AES-192 i AES-256. \newline
    Dodanie paddingu PKCS\#7 i obsługi wektorów inicjalizujących (IV). \newline
    Pełna implementacja algorytmu AES bez użycia zewnętrznych bibliotek kryptograficznych.
    \item \textbf{16.11.2025} Implementacja algorytmu RSA (Rivest-Shamir-Adleman) - pierwszy algorytm kryptografii asymetrycznej w aplikacji. \newline
    Generowanie par kluczy publiczny/prywatny z losowymi liczbami pierwszymi. \newline
    Implementacja algorytmu Euklidesa, rozszerzonego algorytmu Euklidesa i szybkiego potęgowania modularnego. \newline
    Dodanie kategorii "Kryptografia asymetryczna" w rejestrze algorytmów. \newline
    Wprowadzenie koncepcji szyfrowania hybrydowego w dokumentacji. \newline
    \textbf{Dodanie GUI do generowania kluczy RSA} - przycisk "Generuj klucze" z modalem wyświetlającym klucz publiczny i prywatny, możliwość kopiowania i bezpośredniego użycia kluczy w aplikacji.
    \item \textbf{24.11.2025} Implementacja zaawansowanego systemu logowania operacji kryptograficznych. \newline
    Utworzenie \texttt{LogManager} z wzorcem Singleton do centralnego zarządzania logami. \newline
    Dodanie komponentu \texttt{LogsViewer} do wyświetlania historii operacji z interfejsem użytkownika. \newline
    Rejestrowanie szczegółowych kroków algorytmów dla celów edukacyjnych. \newline
    Przechowywanie logów w AsyncStorage z limitem 100 wpisów. \newline
    Funkcje filtrowania, usuwania i eksportu logów. \newline
    Automatyczne maskowanie kluczy dla bezpieczeństwa. \newline
    Statystyki użycia algorytmów (liczba operacji, najczęściej używany algorytm, czas wykonania). \newline
    Integracja systemu logowania ze wszystkimi algorytmami (Cezar, Vigenère, Running Key, AES, RSA).
    \item \textbf{01.12.2025} Implementacja algorytmu ElGamal oraz protokołu ECDH (Elliptic Curve Diffie-Hellman). \newline
    Dodanie obsługi problemu logarytmu dyskretnego w ElGamal. \newline
    Implementacja operacji na krzywych eliptycznych (dodawanie punktów, mnożenie skalarne) dla ECDH. \newline
    Demonstracja schematu ECIES (Elliptic Curve Integrated Encryption Scheme). \newline
    Rozszerzenie dokumentacji o nowe algorytmy asymetryczne.
    \item \textbf{07.12.2025} Implementacja funkcji skrótu SHA-256. \newline
    Rejestrowanie szczegółowych kroków funkcji skrótu w systemie logowania. \newline
    Dodanie zastosowań SHA-256 w praktyce (blockchain, podpisy cyfrowe). \newline
    Ulepszenie dokumentacji o funkcje skrótu i ich znaczenie w bezpieczeństwie.
    \item \textbf{15.12.2025} Implementacja podpisu elektronicznego łączącego SHA-256 z RSA. \newline
    Proces podpisywania: obliczanie hash SHA-256 → podpisywanie kluczem prywatnym RSA → formatowanie wyniku. \newline
    Proces weryfikacji: obliczanie hash → sprawdzanie integralności → weryfikacja podpisu kluczem publicznym. \newline
    Rejestracja kroków podpisywania i weryfikacji w systemie logowania.
\end{itemize}


\end{document}
